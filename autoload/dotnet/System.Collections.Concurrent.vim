
call dotnet#class('ConcurrentDictionary', 'Object', [ 
  \ dotnet#method('ConcurrentDictionary`2(', ''),
  \ dotnet#method('TryAdd(', ''),
  \ dotnet#method('ContainsKey(', ''),
  \ dotnet#method('TryRemove(', ''),
  \ dotnet#method('TryGetValue(', ''),
  \ dotnet#method('TryUpdate(', ''),
  \ dotnet#method('Clear(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('ToArray(', ''),
  \ dotnet#method('get_Item(', ''),
  \ dotnet#method('set_Item(', ''),
  \ dotnet#method('get_Count(', ''),
  \ dotnet#method('GetOrAdd(', ''),
  \ dotnet#method('AddOrUpdate(', ''),
  \ dotnet#method('get_IsEmpty(', ''),
  \ dotnet#method('Add(', ''),
  \ dotnet#method('Remove(', ''),
  \ dotnet#method('Contains(', ''),
  \ dotnet#method('get_IsReadOnly(', ''),
  \ dotnet#method('Add(', ''),
  \ dotnet#method('Contains(', ''),
  \ dotnet#method('get_IsFixedSize(', ''),
  \ dotnet#method('get_IsReadOnly(', ''),
  \ dotnet#method('Remove(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('get_IsSynchronized(', ''),
  \ dotnet#method('get_SyncRoot(', ''),
  \ dotnet#prop('Item(!TKey)', '!TValue'),
  \ dotnet#prop('Count', 'int32'),
  \ dotnet#prop('IsEmpty', 'bool'),
  \ dotnet#prop('Keys', 'ICollection'),
  \ dotnet#prop('Values', 'ICollection'),
  \ dotnet#prop('IsReadOnly', 'bool'),
  \ dotnet#prop('IsFixedSize', 'bool'),
  \ dotnet#prop('IsReadOnly', 'bool'),
  \ dotnet#prop('Keys', 'ICollection'),
  \ dotnet#prop('Values', 'ICollection'),
  \ dotnet#prop('Item(object)', 'object'),
  \ dotnet#prop('IsSynchronized', 'bool'),
  \ dotnet#prop('SyncRoot', 'object'),
  \ ])

call dotnet#class('ConcurrentQueue', 'Object', [ 
  \ dotnet#method('ConcurrentQueue`1(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('get_IsSynchronized(', ''),
  \ dotnet#method('get_SyncRoot(', ''),
  \ dotnet#method('TryAdd(', ''),
  \ dotnet#method('TryTake(', ''),
  \ dotnet#method('get_IsEmpty(', ''),
  \ dotnet#method('ToArray(', ''),
  \ dotnet#method('get_Count(', ''),
  \ dotnet#method('Enqueue(', ''),
  \ dotnet#method('TryDequeue(', ''),
  \ dotnet#method('TryPeek(', ''),
  \ dotnet#prop('IsSynchronized', 'bool'),
  \ dotnet#prop('SyncRoot', 'object'),
  \ dotnet#prop('IsEmpty', 'bool'),
  \ dotnet#prop('Count', 'int32'),
  \ ])

call dotnet#class('ConcurrentStack', 'Object', [ 
  \ dotnet#method('ConcurrentStack`1(', ''),
  \ dotnet#method('get_IsEmpty(', ''),
  \ dotnet#method('get_Count(', ''),
  \ dotnet#method('get_IsSynchronized(', ''),
  \ dotnet#method('get_SyncRoot(', ''),
  \ dotnet#method('Clear(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('Push(', ''),
  \ dotnet#method('PushRange(', ''),
  \ dotnet#method('TryAdd(', ''),
  \ dotnet#method('TryPeek(', ''),
  \ dotnet#method('TryPop(', ''),
  \ dotnet#method('TryPopRange(', ''),
  \ dotnet#method('TryTake(', ''),
  \ dotnet#method('ToArray(', ''),
  \ dotnet#prop('IsEmpty', 'bool'),
  \ dotnet#prop('Count', 'int32'),
  \ dotnet#prop('IsSynchronized', 'bool'),
  \ dotnet#prop('SyncRoot', 'object'),
  \ ])

call dotnet#class('Partitioner', 'Object', [ 
  \ dotnet#method('get_SupportsDynamicPartitions(', ''),
  \ dotnet#method('Partitioner`1(', ''),
  \ dotnet#prop('SupportsDynamicPartitions', 'bool'),
  \ ])

call dotnet#class('OrderablePartitioner', 'Partitioner', [ 
  \ dotnet#method('OrderablePartitioner`1(', ''),
  \ dotnet#method('get_KeysOrderedInEachPartition(', ''),
  \ dotnet#method('set_KeysOrderedInEachPartition(', ''),
  \ dotnet#method('get_KeysOrderedAcrossPartitions(', ''),
  \ dotnet#method('set_KeysOrderedAcrossPartitions(', ''),
  \ dotnet#method('get_KeysNormalized(', ''),
  \ dotnet#method('set_KeysNormalized(', ''),
  \ dotnet#method('GetPartitions(', ''),
  \ dotnet#method('GetDynamicPartitions(', ''),
  \ dotnet#prop('KeysOrderedInEachPartition', 'bool'),
  \ dotnet#prop('KeysOrderedAcrossPartitions', 'bool'),
  \ dotnet#prop('KeysNormalized', 'bool'),
  \ ])

call dotnet#class('Partitioner', 'Object', [ 
  \ dotnet#method('Create(', ''),
  \ ])

call dotnet#class('BlockingCollection', 'Object', [ 
  \ dotnet#method('get_BoundedCapacity(', ''),
  \ dotnet#method('get_IsAddingCompleted(', ''),
  \ dotnet#method('get_IsCompleted(', ''),
  \ dotnet#method('get_Count(', ''),
  \ dotnet#method('get_IsSynchronized(', ''),
  \ dotnet#method('get_SyncRoot(', ''),
  \ dotnet#method('BlockingCollection`1(', ''),
  \ dotnet#method('Add(', ''),
  \ dotnet#method('TryAdd(', ''),
  \ dotnet#method('Take(', ''),
  \ dotnet#method('TryTake(', ''),
  \ dotnet#method('AddToAny(', ''),
  \ dotnet#method('TryAddToAny(', ''),
  \ dotnet#method('TakeFromAny(', ''),
  \ dotnet#method('TryTakeFromAny(', ''),
  \ dotnet#method('CompleteAdding(', ''),
  \ dotnet#method('Dispose(', ''),
  \ dotnet#method('ToArray(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('GetConsumingEnumerable(', ''),
  \ dotnet#prop('BoundedCapacity', 'int32'),
  \ dotnet#prop('IsAddingCompleted', 'bool'),
  \ dotnet#prop('IsCompleted', 'bool'),
  \ dotnet#prop('Count', 'int32'),
  \ dotnet#prop('IsSynchronized', 'bool'),
  \ dotnet#prop('SyncRoot', 'object'),
  \ ])

call dotnet#class('ConcurrentBag', 'Object', [ 
  \ dotnet#method('ConcurrentBag`1(', ''),
  \ dotnet#method('Add(', ''),
  \ dotnet#method('TryAdd(', ''),
  \ dotnet#method('TryTake(', ''),
  \ dotnet#method('TryPeek(', ''),
  \ dotnet#method('CopyTo(', ''),
  \ dotnet#method('ToArray(', ''),
  \ dotnet#method('get_Count(', ''),
  \ dotnet#method('get_IsEmpty(', ''),
  \ dotnet#method('get_IsSynchronized(', ''),
  \ dotnet#method('get_SyncRoot(', ''),
  \ dotnet#prop('Count', 'int32'),
  \ dotnet#prop('IsEmpty', 'bool'),
  \ dotnet#prop('IsSynchronized', 'bool'),
  \ dotnet#prop('SyncRoot', 'object'),
  \ ])

