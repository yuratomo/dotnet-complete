call dotnet#namespace('System.Threading.Tasks')

call dotnet#class('Task', 'Object', [ 
  \ dotnet#field('m_internalCancellationRequested', 'IsVolatile)'),
  \ dotnet#field('m_completionCountdown', 'IsVolatile)'),
  \ dotnet#field('m_exceptionsHolder', 'IsVolatile)'),
  \ dotnet#field('m_exceptionalChildren', 'IsVolatile)'),
  \ dotnet#field('m_continuations', 'IsVolatile)'),
  \ dotnet#field('m_cancellationToken', 'CancellationToken'),
  \ dotnet#field('m_cancellationRegistration', 'Shared'),
  \ dotnet#method('Task(', ')', 'void'),
  \ dotnet#field('m_task', 'object'),
  \ dotnet#field('m_taskScheduler', 'TaskScheduler'),
  \ dotnet#field('m_options', 'TaskContinuationOptions'),
  \ dotnet#method('Task(', 'class Task task, TaskScheduler scheduler, TaskContinuationOptions options)', 'void'),
  \ dotnet#method('Task(', 'class Action action)', 'void'),
  \ dotnet#method('Run(', 'class Task completedTask, bool bCanInlineContinuationTask)', 'void'),
  \ dotnet#field('m_action', 'object'),
  \ dotnet#field('m_stateObject', 'object'),
  \ dotnet#field('m_taskScheduler', 'TaskScheduler'),
  \ dotnet#field('m_parent', 'Task'),
  \ dotnet#field('m_capturedContext', 'ExecutionContext'),
  \ dotnet#field('m_stateFlags', 'IsVolatile)'),
  \ dotnet#field('m_contingentProperties', 'IsVolatile)'),
  \ dotnet#method('Task(', ')', 'static void .'),
  \ dotnet#method('Task(', 'bool canceled, TaskCreationOptions creationOptions)', 'void'),
  \ dotnet#method('Task(', 'object state, CancellationToken cancelationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, bool promiseStyle)', 'void'),
  \ dotnet#method('Task(', 'class Action action) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, CancellationToken cancellationToken) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, TaskCreationOptions creationOptions) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, object state) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, object state, CancellationToken cancellationToken) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, object state, TaskCreationOptions creationOptions) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions) noinlining', 'void'),
  \ dotnet#method('Task(', 'class Action action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'void'),
  \ dotnet#method('Task(', 'object action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)', 'void'),
  \ dotnet#method('TaskConstrTaskCore(', 'object action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler)', 'void'),
  \ dotnet#method('DeregisterCancellationCallback(', ')', 'void'),
  \ dotnet#method('PossiblyCaptureContext(', 'StackCrawlMark& stackMark)', 'void'),
  \ dotnet#method('get_Options(', ')', '.method'),
  \ dotnet#method('AtomicStateUpdate(', 'int32 newBits, int32 illegalBits)', 'bool'),
  \ dotnet#method('AtomicStateUpdate(', 'int32 newBits, int32 illegalBits, int32& oldFlags)', 'bool'),
  \ dotnet#method('MarkStarted(', ')', 'bool'),
  \ dotnet#method('AddNewChild(', ')', 'void'),
  \ dotnet#method('DisregardChild(', ')', 'void'),
  \ dotnet#method('Start(', ')', 'void'),
  \ dotnet#method('Start(', 'class TaskScheduler scheduler)', 'void'),
  \ dotnet#method('RunSynchronously(', ')', 'void'),
  \ dotnet#method('RunSynchronously(', 'class TaskScheduler scheduler)', 'void'),
  \ dotnet#method('InternalRunSynchronously(', 'class TaskScheduler scheduler)', 'void'),
  \ dotnet#method('InternalStartNew(', 'class Task creatingTask, object action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('InternalStartNew(', 'class Task creatingTask, object action, object state, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, ExecutionContext context)', 'static Task'),
  \ dotnet#method('get_Id(', ')', 'int32'),
  \ dotnet#method('get_CurrentId(', ')', 'static'),
  \ dotnet#method('get_InternalCurrent(', ')', 'static'),
  \ dotnet#method('get_CurrentStackGuard(', ')', 'static'),
  \ dotnet#method('get_Exception(', ')', 'AggregateException'),
  \ dotnet#method('get_Status(', ')', 'TaskStatus'),
  \ dotnet#method('get_IsCanceled(', ')', 'bool'),
  \ dotnet#method('get_IsCancellationRequested(', ')', 'bool'),
  \ dotnet#method('get_CancellationToken(', ')', '.method'),
  \ dotnet#method('get_IsCancellationAcknowledged(', ')', 'bool'),
  \ dotnet#method('get_IsCompleted(', ')', 'bool'),
  \ dotnet#method('get_CompletedSuccessfully(', ')', 'bool'),
  \ dotnet#method('get_IsDisposed(', ')', 'bool'),
  \ dotnet#method('ThrowIfDisposed(', ')', 'void'),
  \ dotnet#method('get_CreationOptions(', ')', 'TaskCreationOptions'),
  \ dotnet#method('get_AsyncWaitHandle(', ')', ''),
  \ dotnet#method('get_InternalAsyncState(', ')', 'strict object'),
  \ dotnet#method('get_AsyncState(', ')', 'object'),
  \ dotnet#method('get_CompletedSynchronously(', ')', 'bool '),
  \ dotnet#method('get_ExecutingTaskScheduler(', ')', '.method'),
  \ dotnet#method('get_FTasky(', ')', 'static'),
  \ dotnet#method('get_CompletedEvent(', ')', '.method'),
  \ dotnet#method('get_IsSelfReplicatingRoot(', ')', 'bool'),
  \ dotnet#method('get_IsChildReplica(', ')', 'bool'),
  \ dotnet#method('get_ActiveChildCount(', ')', 'int32'),
  \ dotnet#method('get_ExceptionRecorded(', ')', 'bool'),
  \ dotnet#method('get_IsFaulted(', ')', 'bool'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#method('ScheduleAndStart(', 'bool needsProtection)', 'void'),
  \ dotnet#method('AddException(', 'object exceptionObject)', 'void'),
  \ dotnet#method('ThrowIfExceptional(', 'bool includeTaskCanceledExceptions)', 'void'),
  \ dotnet#method('UpdateExceptionObservedStatus(', ')', 'void'),
  \ dotnet#method('get_IsExceptionObservedByParent(', ')', 'bool'),
  \ dotnet#method('get_IsDelegateInvoked(', ')', 'bool'),
  \ dotnet#method('Finish(', 'bool bUserDelegateExecuted)', 'void'),
  \ dotnet#method('FinishStageTwo(', ')', 'void'),
  \ dotnet#method('ProcessChildCompletion(', 'class Task childTask)', 'void'),
  \ dotnet#method('AddExceptionsFromChildren(', ')', 'void'),
  \ dotnet#method('FinishThreadAbortedTask(', 'bool bTAEAddedToExceptionHolder, bool delegateRan)', 'void'),
  \ dotnet#method('ShouldReplicate(', ')', 'strict bool'),
  \ dotnet#method('CreateReplicaTask(', 'class Action taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica)', 'strict'),
  \ dotnet#method('get_SavedStateForNextReplica(', ')', 'strict object'),
  \ dotnet#method('set_SavedStateForNextReplica(', 'object value)', 'strict void'),
  \ dotnet#method('get_SavedStateFromPreviousReplica(', ')', 'strict object'),
  \ dotnet#method('set_SavedStateFromPreviousReplica(', 'object value)', 'strict void'),
  \ dotnet#method('get_HandedOverChildReplica(', ')', 'strict'),
  \ dotnet#method('set_HandedOverChildReplica(', 'class Task value)', 'strict void'),
  \ dotnet#method('ExecuteWorkItem(', ')', 'void '),
  \ dotnet#method('MarkAborted(', 'class ThreadAbortException tae)', 'void '),
  \ dotnet#method('ExecuteEntry(', 'bool bPreventDoubleExecution)', 'bool'),
  \ dotnet#method('InnerInvoke(', ')', 'void'),
  \ dotnet#method('InnerInvokeWithArg(', 'class Task childTask) noinlining', 'void'),
  \ dotnet#method('Wait(', ')', 'void'),
  \ dotnet#method('Wait(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('Wait(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('InternalWait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('InternalCancel(', 'bool bCancelNonExecutingOnly)', 'bool'),
  \ dotnet#method('RecordInternalCancellationRequest(', ')', 'void'),
  \ dotnet#method('CancellationCleanupLogic(', ')', 'void'),
  \ dotnet#method('ContinueWithIsRightKind(', 'TaskContinuationOptions options)', 'bool'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('CreationOptionsFromContinuationOptions(', 'TaskContinuationOptions continuationOptions, [out] TaskCreationOptions& creationOptions, [out] InternalTaskOptions& internalOptions)', 'static void'),
  \ dotnet#method('ContinueWithCore(', 'class Task continuationTask, TaskScheduler scheduler, TaskContinuationOptions options)', 'void'),
  \ dotnet#method('AddCompletionAction(', 'class Action action)', 'void'),
  \ dotnet#method('WaitAll(', 'class Task[] tasks)', 'static void'),
  \ dotnet#method('WaitAll(', 'class Task[] tasks, TimeSpan timeout)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class Task[] tasks, int32 millisecondsTimeout)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class Task[] tasks, CancellationToken cancellationToken)', 'static void'),
  \ dotnet#method('WaitAll(', 'class Task[] tasks, int32 millisecondsTimeout, CancellationToken cancellationToken)', 'static bool'),
  \ dotnet#method('FastWaitAll(', 'class Task[] tasks)', 'static void'),
  \ dotnet#method('AddExceptionsForCompletedTask(', 'class List& exceptions, Task t)', 'static void'),
  \ dotnet#method('WaitAny(', 'class Task[] tasks)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class Task[] tasks, TimeSpan timeout)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class Task[] tasks, CancellationToken cancellationToken)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class Task[] tasks, int32 millisecondsTimeout)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class Task[] tasks, int32 millisecondsTimeout, CancellationToken cancellationToken)', 'static int32'),
  \ dotnet#prop('Options', 'TaskCreationOptions'),
  \ dotnet#prop('Id', 'int32'),
  \ dotnet#prop('CurrentId', 'Nullable'),
  \ dotnet#prop('InternalCurrent', 'Task'),
  \ dotnet#prop('CurrentStackGuard', 'StackGuard'),
  \ dotnet#prop('Exception', 'AggregateException'),
  \ dotnet#prop('Status', 'TaskStatus'),
  \ dotnet#prop('IsCanceled', 'bool'),
  \ dotnet#prop('IsCancellationRequested', 'bool'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('IsCancellationAcknowledged', 'bool'),
  \ dotnet#prop('IsCompleted', 'bool'),
  \ dotnet#prop('CompletedSuccessfully', 'bool'),
  \ dotnet#prop('IsDisposed', 'bool'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('AsyncWaitHandle', 'WaitHandle'),
  \ dotnet#prop('InternalAsyncState', 'object'),
  \ dotnet#prop('AsyncState', 'object'),
  \ dotnet#prop('CompletedSynchronously', 'bool'),
  \ dotnet#prop('ExecutingTaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('FTasky', 'TaskFTasky'),
  \ dotnet#prop('CompletedEvent', 'ManualResetEventSlim'),
  \ dotnet#prop('IsSelfReplicatingRoot', 'bool'),
  \ dotnet#prop('IsChildReplica', 'bool'),
  \ dotnet#prop('ActiveChildCount', 'int32'),
  \ dotnet#prop('ExceptionRecorded', 'bool'),
  \ dotnet#prop('IsFaulted', 'bool'),
  \ dotnet#prop('IsExceptionObservedByParent', 'bool'),
  \ dotnet#prop('IsDelegateInvoked', 'bool'),
  \ dotnet#prop('SavedStateForNextReplica', 'object'),
  \ dotnet#prop('SavedStateFromPreviousReplica', 'object'),
  \ dotnet#prop('HandedOverChildReplica', 'Task'),
  \ ])

call dotnet#class('Task', 'Task', [ 
  \ dotnet#field('m_resultWasSet', 'bool'),
  \ dotnet#method('Task`1(', 'object state, CancellationToken cancellationToken, TaskCreationOptions options, InternalTaskOptions internalOptions)', 'void Task`'),
  \ dotnet#method('Task`1(', 'bool canceled, !TResult result, TaskCreationOptions creationOptions)', 'void Task`'),
  \ dotnet#method('StartNew(', 'class Task parent, Func function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('StartNew(', 'class Task parent, Func function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('TrySetResult(', '!TResult result)', 'bool'),
  \ dotnet#method('get_Result(', ')', '!TResult'),
  \ dotnet#method('set_Result(', '!TResult value)', 'void'),
  \ dotnet#method('TrySetException(', 'object exceptionObject)', 'bool'),
  \ dotnet#method('get_FTask`1y(', ')', 'static get_FTask`'),
  \ dotnet#method('get_InternalAsyncState(', ')', 'strict object'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Action continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWith(', 'class Func continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark& stackMark)', 'Task'),
  \ dotnet#method('Task`1(', ')', 'static void .Task`'),
  \ dotnet#prop('Result', '!TResult'),
  \ dotnet#prop('FTask`1y', 'TaskFTask'),
  \ dotnet#prop('InternalAsyncState', 'object'),
  \ ])

call dotnet#class('TaskFTaskFactory', 'Object', [ 
  \ dotnet#method('TaskFactory`1(', ')', 'void TaskFactory`'),
  \ dotnet#method('TaskFactory`1(', 'CancellationToken cancellationToken)', 'void TaskFactory`'),
  \ dotnet#method('TaskFactory`1(', 'class TaskScheduler scheduler)', 'void TaskFactory`'),
  \ dotnet#method('TaskFactory`1(', 'TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions)', 'void TaskFactory`'),
  \ dotnet#method('TaskFactory`1(', 'CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)', 'void TaskFactory`'),
  \ dotnet#method('get_CancellationToken(', ')', 'CancellationToken'),
  \ dotnet#method('get_Scheduler(', ')', 'TaskScheduler'),
  \ dotnet#method('get_CreationOptions(', ')', 'TaskCreationOptions'),
  \ dotnet#method('get_ContinuationOptions(', ')', 'TaskContinuationOptions'),
  \ dotnet#method('StartNew(', 'class Func function) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('FromAsyncImpl(', 'class IAsyncResult asyncResult, Func endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsyncImpl(', 'class Func beginMethod, Func endMethod, object state, TaskCreationOptions creationOptions)', 'static Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsyncImpl(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, object state, TaskCreationOptions creationOptions)', 'static Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsyncImpl(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, TaskCreationOptions creationOptions)', 'static Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsyncImpl(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, TaskCreationOptions creationOptions)', 'static Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark& stackMark)', 'static Task'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('Scheduler', 'TaskScheduler'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('ContinuationOptions', 'TaskContinuationOptions'),
  \ ])

call dotnet#class('ParallelOptions', 'Object', [ 
  \ dotnet#method('ParallelOptions(', ')', 'void'),
  \ dotnet#method('get_TaskScheduler(', ')', 'TaskScheduler'),
  \ dotnet#method('set_TaskScheduler(', 'class TaskScheduler value)', 'void'),
  \ dotnet#method('get_EffectiveTaskScheduler(', ')', '.method'),
  \ dotnet#method('get_MaxDegreeOfParallelism(', ')', 'int32'),
  \ dotnet#method('set_MaxDegreeOfParallelism(', 'int32 value)', 'void'),
  \ dotnet#method('get_CancellationToken(', ')', 'CancellationToken'),
  \ dotnet#method('set_CancellationToken(', 'CancellationToken value)', 'void'),
  \ dotnet#method('get_EffectiveMaxConcurrencyLevel(', ')', 'int32'),
  \ dotnet#prop('TaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('EffectiveTaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('MaxDegreeOfParallelism', 'int32'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('EffectiveMaxConcurrencyLevel', 'int32'),
  \ ])

call dotnet#class('Parallel', 'Object', [ 
  \ dotnet#field('m_timeLimit', 'int32'),
  \ dotnet#method('Parallel(', 'int32 nWorkerTaskIndex)', 'void'),
  \ dotnet#method('LimitExceeded(', ')', 'bool'),
  \ dotnet#method('Invoke(', 'class Action[] actions)', 'static void'),
  \ dotnet#method('Invoke(', 'class ParallelOptions parallelOptions, Action[] actions)', 'static void'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int32 fromInclusive, int32 toExclusive, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('For(', 'int64 fromInclusive, int64 toExclusive, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class IEnumerable source, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class OrderablePartitioner source, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class OrderablePartitioner source, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class OrderablePartitioner source, ParallelOptions parallelOptions, Action body)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class Partitioner source, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ForEach(', 'class OrderablePartitioner source, ParallelOptions parallelOptions, Func localInit, Func body, Action localFinally)', 'static ParallelLoopResult'),
  \ dotnet#method('ThrowIfReducableToSingleOCE(', 'class IEnumerable excCollection, CancellationToken ct)', 'static void'),
  \ dotnet#method('Parallel(', ')', 'static void .'),
  \ ])

call dotnet#class('ParallelLoopState', 'Object', [ 
  \ dotnet#method('ParallelLoopState(', 'class ParallelLoopStateFlags fbase)', 'void'),
  \ dotnet#method('get_InternalShouldExitCurrentIteration(', ')', 'strict bool'),
  \ dotnet#method('get_ShouldExitCurrentIteration(', ')', 'bool'),
  \ dotnet#method('get_IsStopped(', ')', 'bool'),
  \ dotnet#method('get_IsExceptional(', ')', 'bool'),
  \ dotnet#method('get_InternalLowestBreakIteration(', ')', 'strict'),
  \ dotnet#method('get_LowestBreakIteration(', ')', 'Nullable'),
  \ dotnet#method('Stop(', ')', 'void'),
  \ dotnet#method('InternalBreak(', ')', 'strict void'),
  \ dotnet#method('Break(', ')', 'void'),
  \ dotnet#method('Break(', 'int32 iteration, ParallelLoopStateFlags32 pflags)', 'static void'),
  \ dotnet#method('Break(', 'int64 iteration, ParallelLoopStateFlags64 pflags)', 'static void'),
  \ dotnet#prop('InternalShouldExitCurrentIteration', 'bool'),
  \ dotnet#prop('ShouldExitCurrentIteration', 'bool'),
  \ dotnet#prop('IsStopped', 'bool'),
  \ dotnet#prop('IsExceptional', 'bool'),
  \ dotnet#prop('InternalLowestBreakIteration', 'Nullable'),
  \ dotnet#prop('LowestBreakIteration', 'Nullable'),
  \ ])

call dotnet#class('ParallelLoopResult', 'ValueType', [ 
  \ dotnet#field('m_completed', 'bool'),
  \ dotnet#field('m_lowestBreakIteration', 'Nullable'),
  \ dotnet#method('get_IsCompleted(', ')', 'bool'),
  \ dotnet#method('get_LowestBreakIteration(', ')', 'Nullable'),
  \ dotnet#prop('IsCompleted', 'bool'),
  \ dotnet#prop('LowestBreakIteration', 'Nullable'),
  \ ])

call dotnet#class('TaskCanceledException', 'OperationCanceledException', [ 
  \ dotnet#method('TaskCanceledException(', ')', 'void'),
  \ dotnet#method('TaskCanceledException(', 'string message)', 'void'),
  \ dotnet#method('TaskCanceledException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('TaskCanceledException(', 'class Task task)', 'void'),
  \ dotnet#method('TaskCanceledException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('get_Task(', ')', 'Task'),
  \ dotnet#prop('Task', 'Task'),
  \ ])

call dotnet#class('TaskSchedulerException', 'Exception', [ 
  \ dotnet#method('TaskSchedulerException(', ')', 'void'),
  \ dotnet#method('TaskSchedulerException(', 'string message)', 'void'),
  \ dotnet#method('TaskSchedulerException(', 'class Exception innerException)', 'void'),
  \ dotnet#method('TaskSchedulerException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('TaskSchedulerException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('TaskFTaskFactoryy', 'Object', [ 
  \ dotnet#method('TaskFactory(', ')', 'void'),
  \ dotnet#method('TaskFactory(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('TaskFactory(', 'class TaskScheduler scheduler)', 'void'),
  \ dotnet#method('TaskFactory(', 'TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions)', 'void'),
  \ dotnet#method('TaskFactory(', 'CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler)', 'void'),
  \ dotnet#method('CheckCreationOptions(', 'TaskCreationOptions creationOptions)', 'static void'),
  \ dotnet#method('get_CancellationToken(', ')', 'CancellationToken'),
  \ dotnet#method('get_Scheduler(', ')', 'TaskScheduler'),
  \ dotnet#method('get_CreationOptions(', ')', 'TaskCreationOptions'),
  \ dotnet#method('get_ContinuationOptions(', ')', 'TaskContinuationOptions'),
  \ dotnet#method('StartNew(', 'class Action action) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, object state) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, object state, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, object state, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Action action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('StartNew(', 'class Func function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Action endMethod) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Action endMethod, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Action endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, !!TArg2 arg2, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Action endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod, TaskCreationOptions creationOptions) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class IAsyncResult asyncResult, Func endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state)', 'Task'),
  \ dotnet#method('FromAsync(', 'class Func beginMethod, Func endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, TaskCreationOptions creationOptions)', 'Task'),
  \ dotnet#method('CheckFromAsyncOptions(', 'TaskCreationOptions creationOptions, bool hasBeginMethod)', 'static void'),
  \ dotnet#method('CommonCWAllLogic(', 'class Task[] tasksCopy)', 'static Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAll(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('CommonCWAnyLogic(', 'class Task[] tasksCopy)', 'static Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Func continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, TaskContinuationOptions continuationOptions) noinlining', 'Task'),
  \ dotnet#method('ContinueWhenAny(', 'class Task[] tasks, Action continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler) noinlining', 'Task'),
  \ dotnet#method('CheckMultiContinuationTasksAndCopy(', 'class Task[] tasks)', 'static Task[]'),
  \ dotnet#method('CheckMultiContinuationTasksAndCopy(', 'class Task[] tasks)', 'static Task[]'),
  \ dotnet#method('CheckMultiTaskContinuationOptions(', 'TaskContinuationOptions continuationOptions)', 'static void'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('Scheduler', 'TaskScheduler'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('ContinuationOptions', 'TaskContinuationOptions'),
  \ ])

call dotnet#class('TaskScheduler', 'Object', [ 
  \ dotnet#method('TaskScheduler(', 'class TaskScheduler scheduler)', 'void'),
  \ dotnet#method('get_Id(', ')', 'int32'),
  \ dotnet#method('get_ScheduledTasks(', ')', ''),
  \ dotnet#prop('Id', 'int32'),
  \ dotnet#prop('ScheduledTasks', 'IEnumerable'),
  \ dotnet#field('m_weakReferenceToSelf', 'WeakReference'),
  \ dotnet#method('QueueTask(', 'class Task task)', 'famorassem abstract void'),
  \ dotnet#method('TryExecuteTaskInline(', 'class Task task, bool taskWasPreviouslyQueued)', 'abstract bool'),
  \ dotnet#method('GetScheduledTasks(', ')', 'abstract'),
  \ dotnet#method('get_MaximumConcurrencyLevel(', ')', 'int32'),
  \ dotnet#method('GetThreadStatics(', ')', 'strict object'),
  \ dotnet#method('TryRunInline(', 'class Task task, bool taskWasPreviouslyQueued, object threadStatics)', 'bool'),
  \ dotnet#method('TryRunInline(', 'class Task task, bool taskWasPreviouslyQueued)', 'bool'),
  \ dotnet#method('TryDequeue(', 'class Task task)', 'famorassem bool'),
  \ dotnet#method('NotifyWorkItemProgress(', ')', 'strict void'),
  \ dotnet#method('get_RequiresAtomicStartTransition(', ')', 'strict bool'),
  \ dotnet#method('TaskScheduler(', ')', 'void'),
  \ dotnet#method('Finalize(', ')', 'void'),
  \ dotnet#method('get_Default(', ')', 'static'),
  \ dotnet#method('get_Current(', ')', 'static'),
  \ dotnet#method('FromCurrentSynchronizationContext(', ')', 'static TaskScheduler'),
  \ dotnet#method('get_Id(', ')', 'int32'),
  \ dotnet#method('TryExecuteTask(', 'class Task task)', 'bool'),
  \ dotnet#method('add_UnobservedTaskException(', 'class EventHandler value)', 'static void'),
  \ dotnet#method('remove_UnobservedTaskException(', 'class EventHandler value)', 'static void'),
  \ dotnet#method('PublishUnobservedTaskException(', 'object sender, UnobservedTaskExceptionEventArgs ueea)', 'static void'),
  \ dotnet#method('GetScheduledTasksForDebugger(', ')', 'Task[]'),
  \ dotnet#method('GetTaskSchedulersForDebugger(', ')', 'static TaskScheduler[]'),
  \ dotnet#method('RegisterTaskScheduler(', 'class TaskScheduler ts)', 'static void'),
  \ dotnet#method('UnregisterTaskScheduler(', 'class TaskScheduler ts)', 'static void'),
  \ dotnet#method('TaskScheduler(', ')', 'static void .'),
  \ dotnet#event('UnobservedTaskException', 'EventHandler'),
  \ dotnet#prop('MaximumConcurrencyLevel', 'int32'),
  \ dotnet#prop('RequiresAtomicStartTransition', 'bool'),
  \ dotnet#prop('Default', 'TaskScheduler'),
  \ dotnet#prop('Current', 'TaskScheduler'),
  \ dotnet#prop('Id', 'int32'),
  \ ])

call dotnet#class('UnobservedTaskExceptionEventArgs', 'EventArgs', [ 
  \ dotnet#field('m_observed', 'bool'),
  \ dotnet#method('UnobservedTaskExceptionEventArgs(', 'class AggregateException exception)', 'void'),
  \ dotnet#method('SetObserved(', ')', 'void'),
  \ dotnet#method('get_Observed(', ')', 'bool'),
  \ dotnet#method('get_Exception(', ')', 'AggregateException'),
  \ dotnet#prop('Observed', 'bool'),
  \ dotnet#prop('Exception', 'AggregateException'),
  \ ])

call dotnet#class('TaskCompletionSource', 'Object', [ 
  \ dotnet#method('TaskCompletionSource`1(', ')', 'void TaskCompletionSource`'),
  \ dotnet#method('TaskCompletionSource`1(', 'TaskCreationOptions creationOptions)', 'void TaskCompletionSource`'),
  \ dotnet#method('TaskCompletionSource`1(', 'object state)', 'void TaskCompletionSource`'),
  \ dotnet#method('TaskCompletionSource`1(', 'object state, TaskCreationOptions creationOptions)', 'void TaskCompletionSource`'),
  \ dotnet#method('get_Task(', ')', 'Task'),
  \ dotnet#method('TrySetException(', 'class Exception exception)', 'bool'),
  \ dotnet#method('TrySetException(', 'class IEnumerable exceptions)', 'bool'),
  \ dotnet#method('SetException(', 'class Exception exception)', 'void'),
  \ dotnet#method('SetException(', 'class IEnumerable exceptions)', 'void'),
  \ dotnet#method('TrySetResult(', '!TResult result)', 'bool'),
  \ dotnet#method('SetResult(', '!TResult result)', 'void'),
  \ dotnet#method('SetCanceled(', ')', 'void'),
  \ dotnet#method('TrySetCanceled(', ')', 'bool'),
  \ dotnet#prop('Task', 'Task'),
  \ ])

call dotnet#class('TaskExtensions', 'Object', [ 
  \ dotnet#method('Unwrap(', 'class Task task)', 'static Task'),
  \ dotnet#method('Unwrap(', 'class Task task)', 'static Task'),
  \ ])

