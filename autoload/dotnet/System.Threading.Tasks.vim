
call dotnet#class('Task', 'Object', [ 
  \ dotnet#field('m_internalCancellationRequested', 'IsVolatile)'),
  \ dotnet#field('m_completionCountdown', 'IsVolatile)'),
  \ dotnet#field('m_exceptionsHolder', 'IsVolatile)'),
  \ dotnet#field('m_exceptionalChildren', 'IsVolatile)'),
  \ dotnet#field('m_continuations', 'IsVolatile)'),
  \ dotnet#field('m_cancellationToken', 'CancellationToken'),
  \ dotnet#field('m_cancellationRegistration', 'Shared'),
  \ dotnet#method('Task(', ''),
  \ dotnet#field('m_task', 'object'),
  \ dotnet#field('m_taskScheduler', 'TaskScheduler'),
  \ dotnet#field('m_options', 'TaskContinuationOptions'),
  \ dotnet#method('Run(', ''),
  \ dotnet#field('m_action', 'object'),
  \ dotnet#field('m_stateObject', 'object'),
  \ dotnet#field('m_taskScheduler', 'TaskScheduler'),
  \ dotnet#field('m_parent', 'Task'),
  \ dotnet#field('m_capturedContext', 'ExecutionContext'),
  \ dotnet#field('m_stateFlags', 'IsVolatile)'),
  \ dotnet#field('m_contingentProperties', 'IsVolatile)'),
  \ dotnet#method('TaskConstrTaskCore(', ''),
  \ dotnet#method('DeregisterCancellationCallback(', ''),
  \ dotnet#method('PossiblyCaptureContext(', ''),
  \ dotnet#method('AtomicStateUpdate(', ''),
  \ dotnet#method('MarkStarted(', ''),
  \ dotnet#method('AddNewChild(', ''),
  \ dotnet#method('DisregardChild(', ''),
  \ dotnet#method('Start(', ''),
  \ dotnet#method('RunSynchronously(', ''),
  \ dotnet#method('InternalRunSynchronously(', ''),
  \ dotnet#method('InternalStartNew(', ''),
  \ dotnet#method('get_Id(', ''),
  \ dotnet#method('get_Exception(', ''),
  \ dotnet#method('get_Status(', ''),
  \ dotnet#method('get_IsCanceled(', ''),
  \ dotnet#method('get_IsCancellationRequested(', ''),
  \ dotnet#method('get_IsCancellationAcknowledged(', ''),
  \ dotnet#method('get_IsCompleted(', ''),
  \ dotnet#method('get_CompletedSuccessfully(', ''),
  \ dotnet#method('get_IsDisposed(', ''),
  \ dotnet#method('ThrowIfDisposed(', ''),
  \ dotnet#method('get_CreationOptions(', ''),
  \ dotnet#method('get_InternalAsyncState(', ''),
  \ dotnet#method('get_AsyncState(', ''),
  \ dotnet#method('get_CompletedSynchronously(', ''),
  \ dotnet#method('get_IsSelfReplicatingRoot(', ''),
  \ dotnet#method('get_IsChildReplica(', ''),
  \ dotnet#method('get_ActiveChildCount(', ''),
  \ dotnet#method('get_ExceptionRecorded(', ''),
  \ dotnet#method('get_IsFaulted(', ''),
  \ dotnet#method('Dispose(', ''),
  \ dotnet#method('ScheduleAndStart(', ''),
  \ dotnet#method('AddException(', ''),
  \ dotnet#method('ThrowIfExceptional(', ''),
  \ dotnet#method('UpdateExceptionObservedStatus(', ''),
  \ dotnet#method('get_IsExceptionObservedByParent(', ''),
  \ dotnet#method('get_IsDelegateInvoked(', ''),
  \ dotnet#method('Finish(', ''),
  \ dotnet#method('FinishStageTwo(', ''),
  \ dotnet#method('ProcessChildCompletion(', ''),
  \ dotnet#method('AddExceptionsFromChildren(', ''),
  \ dotnet#method('FinishThreadAbortedTask(', ''),
  \ dotnet#method('ShouldReplicate(', ''),
  \ dotnet#method('get_SavedStateForNextReplica(', ''),
  \ dotnet#method('set_SavedStateForNextReplica(', ''),
  \ dotnet#method('get_SavedStateFromPreviousReplica(', ''),
  \ dotnet#method('set_SavedStateFromPreviousReplica(', ''),
  \ dotnet#method('set_HandedOverChildReplica(', ''),
  \ dotnet#method('ExecuteWorkItem(', ''),
  \ dotnet#method('MarkAborted(', ''),
  \ dotnet#method('ExecuteEntry(', ''),
  \ dotnet#method('InnerInvoke(', ''),
  \ dotnet#method('InnerInvokeWithArg(', ''),
  \ dotnet#method('Wait(', ''),
  \ dotnet#method('InternalWait(', ''),
  \ dotnet#method('InternalCancel(', ''),
  \ dotnet#method('RecordInternalCancellationRequest(', ''),
  \ dotnet#method('CancellationCleanupLogic(', ''),
  \ dotnet#method('ContinueWithIsRightKind(', ''),
  \ dotnet#method('ContinueWith(', ''),
  \ dotnet#method('CreationOptionsFromContinuationOptions(', ''),
  \ dotnet#method('ContinueWithCore(', ''),
  \ dotnet#method('AddCompletionAction(', ''),
  \ dotnet#method('WaitAll(', ''),
  \ dotnet#method('FastWaitAll(', ''),
  \ dotnet#method('AddExceptionsForCompletedTask(', ''),
  \ dotnet#method('WaitAny(', ''),
  \ dotnet#prop('Options', 'TaskCreationOptions'),
  \ dotnet#prop('Id', 'int32'),
  \ dotnet#prop('CurrentId', 'Nullable'),
  \ dotnet#prop('InternalCurrent', 'Task'),
  \ dotnet#prop('CurrentStackGuard', 'StackGuard'),
  \ dotnet#prop('Exception', 'AggregateException'),
  \ dotnet#prop('Status', 'TaskStatus'),
  \ dotnet#prop('IsCanceled', 'bool'),
  \ dotnet#prop('IsCancellationRequested', 'bool'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('IsCancellationAcknowledged', 'bool'),
  \ dotnet#prop('IsCompleted', 'bool'),
  \ dotnet#prop('CompletedSuccessfully', 'bool'),
  \ dotnet#prop('IsDisposed', 'bool'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('AsyncWaitHandle', 'WaitHandle'),
  \ dotnet#prop('InternalAsyncState', 'object'),
  \ dotnet#prop('AsyncState', 'object'),
  \ dotnet#prop('CompletedSynchronously', 'bool'),
  \ dotnet#prop('ExecutingTaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('FTasky', 'TaskFTasky'),
  \ dotnet#prop('CompletedEvent', 'ManualResetEventSlim'),
  \ dotnet#prop('IsSelfReplicatingRoot', 'bool'),
  \ dotnet#prop('IsChildReplica', 'bool'),
  \ dotnet#prop('ActiveChildCount', 'int32'),
  \ dotnet#prop('ExceptionRecorded', 'bool'),
  \ dotnet#prop('IsFaulted', 'bool'),
  \ dotnet#prop('IsExceptionObservedByParent', 'bool'),
  \ dotnet#prop('IsDelegateInvoked', 'bool'),
  \ dotnet#prop('SavedStateForNextReplica', 'object'),
  \ dotnet#prop('SavedStateFromPreviousReplica', 'object'),
  \ dotnet#prop('HandedOverChildReplica', 'Task'),
  \ ])

call dotnet#class('Task', 'Task', [ 
  \ dotnet#field('m_resultWasSet', 'bool'),
  \ dotnet#method('Task`1(', ''),
  \ dotnet#method('StartNew(', ''),
  \ dotnet#method('TrySetResult(', ''),
  \ dotnet#method('get_Result(', ''),
  \ dotnet#method('set_Result(', ''),
  \ dotnet#method('TrySetException(', ''),
  \ dotnet#method('get_InternalAsyncState(', ''),
  \ dotnet#method('ContinueWith(', ''),
  \ dotnet#prop('Result', '!TResult'),
  \ dotnet#prop('FTask`1y', 'TaskFTask'),
  \ dotnet#prop('InternalAsyncState', 'object'),
  \ ])

call dotnet#class('TaskFTaskFactory', 'Object', [ 
  \ dotnet#method('TaskFactory`1(', ''),
  \ dotnet#method('get_CancellationToken(', ''),
  \ dotnet#method('get_Scheduler(', ''),
  \ dotnet#method('get_CreationOptions(', ''),
  \ dotnet#method('get_ContinuationOptions(', ''),
  \ dotnet#method('StartNew(', ''),
  \ dotnet#method('FromAsync(', ''),
  \ dotnet#method('FromAsyncImpl(', ''),
  \ dotnet#method('ContinueWhenAll(', ''),
  \ dotnet#method('ContinueWhenAny(', ''),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('Scheduler', 'TaskScheduler'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('ContinuationOptions', 'TaskContinuationOptions'),
  \ ])

call dotnet#class('ParallelOptions', 'Object', [ 
  \ dotnet#method('ParallelOptions(', ''),
  \ dotnet#method('get_TaskScheduler(', ''),
  \ dotnet#method('set_TaskScheduler(', ''),
  \ dotnet#method('get_MaxDegreeOfParallelism(', ''),
  \ dotnet#method('set_MaxDegreeOfParallelism(', ''),
  \ dotnet#method('get_CancellationToken(', ''),
  \ dotnet#method('set_CancellationToken(', ''),
  \ dotnet#method('get_EffectiveMaxConcurrencyLevel(', ''),
  \ dotnet#prop('TaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('EffectiveTaskScheduler', 'TaskScheduler'),
  \ dotnet#prop('MaxDegreeOfParallelism', 'int32'),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('EffectiveMaxConcurrencyLevel', 'int32'),
  \ ])

call dotnet#class('Parallel', 'Object', [ 
  \ dotnet#field('m_timeLimit', 'int32'),
  \ dotnet#method('Parallel(', ''),
  \ dotnet#method('LimitExceeded(', ''),
  \ dotnet#method('Invoke(', ''),
  \ dotnet#method('For(', ''),
  \ dotnet#method('ForEach(', ''),
  \ dotnet#method('ThrowIfReducableToSingleOCE(', ''),
  \ ])

call dotnet#class('ParallelLoopState', 'Object', [ 
  \ dotnet#method('ParallelLoopState(', ''),
  \ dotnet#method('get_InternalShouldExitCurrentIteration(', ''),
  \ dotnet#method('get_ShouldExitCurrentIteration(', ''),
  \ dotnet#method('get_IsStopped(', ''),
  \ dotnet#method('get_IsExceptional(', ''),
  \ dotnet#method('get_LowestBreakIteration(', ''),
  \ dotnet#method('Stop(', ''),
  \ dotnet#method('InternalBreak(', ''),
  \ dotnet#method('Break(', ''),
  \ dotnet#prop('InternalShouldExitCurrentIteration', 'bool'),
  \ dotnet#prop('ShouldExitCurrentIteration', 'bool'),
  \ dotnet#prop('IsStopped', 'bool'),
  \ dotnet#prop('IsExceptional', 'bool'),
  \ dotnet#prop('InternalLowestBreakIteration', 'Nullable'),
  \ dotnet#prop('LowestBreakIteration', 'Nullable'),
  \ ])

call dotnet#class('ParallelLoopResult', 'ValueType', [ 
  \ dotnet#field('m_completed', 'bool'),
  \ dotnet#field('m_lowestBreakIteration', 'Nullable'),
  \ dotnet#method('get_IsCompleted(', ''),
  \ dotnet#method('get_LowestBreakIteration(', ''),
  \ dotnet#prop('IsCompleted', 'bool'),
  \ dotnet#prop('LowestBreakIteration', 'Nullable'),
  \ ])

call dotnet#class('TaskCanceledException', 'OperationCanceledException', [ 
  \ dotnet#method('TaskCanceledException(', ''),
  \ dotnet#method('get_Task(', ''),
  \ dotnet#prop('Task', 'Task'),
  \ ])

call dotnet#class('TaskSchedulerException', 'Exception', [ 
  \ dotnet#method('TaskSchedulerException(', ''),
  \ ])

call dotnet#class('TaskFTaskFactoryy', 'Object', [ 
  \ dotnet#method('TaskFactory(', ''),
  \ dotnet#method('CheckCreationOptions(', ''),
  \ dotnet#method('get_CancellationToken(', ''),
  \ dotnet#method('get_Scheduler(', ''),
  \ dotnet#method('get_CreationOptions(', ''),
  \ dotnet#method('get_ContinuationOptions(', ''),
  \ dotnet#method('StartNew(', ''),
  \ dotnet#method('FromAsync(', ''),
  \ dotnet#method('CheckFromAsyncOptions(', ''),
  \ dotnet#method('CommonCWAllLogic(', ''),
  \ dotnet#method('ContinueWhenAll(', ''),
  \ dotnet#method('CommonCWAnyLogic(', ''),
  \ dotnet#method('ContinueWhenAny(', ''),
  \ dotnet#method('CheckMultiContinuationTasksAndCopy(', ''),
  \ dotnet#method('CheckMultiTaskContinuationOptions(', ''),
  \ dotnet#prop('CancellationToken', 'CancellationToken'),
  \ dotnet#prop('Scheduler', 'TaskScheduler'),
  \ dotnet#prop('CreationOptions', 'TaskCreationOptions'),
  \ dotnet#prop('ContinuationOptions', 'TaskContinuationOptions'),
  \ ])

call dotnet#class('TaskScheduler', 'Object', [ 
  \ dotnet#method('TaskScheduler(', ''),
  \ dotnet#method('get_Id(', ''),
  \ dotnet#prop('Id', 'int32'),
  \ dotnet#prop('ScheduledTasks', 'IEnumerable'),
  \ dotnet#field('m_weakReferenceToSelf', 'WeakReference'),
  \ dotnet#method('QueueTask(', ''),
  \ dotnet#method('TryExecuteTaskInline(', ''),
  \ dotnet#method('get_MaximumConcurrencyLevel(', ''),
  \ dotnet#method('GetThreadStatics(', ''),
  \ dotnet#method('TryRunInline(', ''),
  \ dotnet#method('TryDequeue(', ''),
  \ dotnet#method('NotifyWorkItemProgress(', ''),
  \ dotnet#method('get_RequiresAtomicStartTransition(', ''),
  \ dotnet#method('Finalize(', ''),
  \ dotnet#method('FromCurrentSynchronizationContext(', ''),
  \ dotnet#method('TryExecuteTask(', ''),
  \ dotnet#method('add_UnobservedTaskException(', ''),
  \ dotnet#method('remove_UnobservedTaskException(', ''),
  \ dotnet#method('PublishUnobservedTaskException(', ''),
  \ dotnet#method('GetScheduledTasksForDebugger(', ''),
  \ dotnet#method('GetTaskSchedulersForDebugger(', ''),
  \ dotnet#method('RegisterTaskScheduler(', ''),
  \ dotnet#method('UnregisterTaskScheduler(', ''),
  \ dotnet#event('UnobservedTaskException', 'EventHandler'),
  \ dotnet#prop('MaximumConcurrencyLevel', 'int32'),
  \ dotnet#prop('RequiresAtomicStartTransition', 'bool'),
  \ dotnet#prop('Default', 'TaskScheduler'),
  \ dotnet#prop('Current', 'TaskScheduler'),
  \ dotnet#prop('Id', 'int32'),
  \ ])

call dotnet#class('UnobservedTaskExceptionEventArgs', 'EventArgs', [ 
  \ dotnet#field('m_observed', 'bool'),
  \ dotnet#method('UnobservedTaskExceptionEventArgs(', ''),
  \ dotnet#method('SetObserved(', ''),
  \ dotnet#method('get_Observed(', ''),
  \ dotnet#method('get_Exception(', ''),
  \ dotnet#prop('Observed', 'bool'),
  \ dotnet#prop('Exception', 'AggregateException'),
  \ ])

call dotnet#class('TaskCompletionSource', 'Object', [ 
  \ dotnet#method('TaskCompletionSource`1(', ''),
  \ dotnet#method('get_Task(', ''),
  \ dotnet#method('TrySetException(', ''),
  \ dotnet#method('SetException(', ''),
  \ dotnet#method('TrySetResult(', ''),
  \ dotnet#method('SetResult(', ''),
  \ dotnet#method('SetCanceled(', ''),
  \ dotnet#method('TrySetCanceled(', ''),
  \ dotnet#prop('Task', 'Task'),
  \ ])

call dotnet#class('TaskExtensions', 'Object', [ 
  \ dotnet#method('Unwrap(', ''),
  \ ])

