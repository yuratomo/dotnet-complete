call dotnet#namespace('System.Threading')

call dotnet#class('AbandonedMutexException', 'SystemException', [ 
  \ dotnet#method('AbandonedMutexException(', ')', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'string message)', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'string message, Exception inner)', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'int32 location, WaitHandle handle)', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'string message, int32 location, WaitHandle handle)', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'string message, Exception inner, int32 location, WaitHandle handle)', 'void'),
  \ dotnet#method('AbandonedMutexException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('get_Mutex(', ')', 'Mutex'),
  \ dotnet#method('get_MutexIndex(', ')', 'int32'),
  \ dotnet#prop('Mutex', 'Mutex'),
  \ dotnet#prop('MutexIndex', 'int32'),
  \ ])

call dotnet#class('WaitHandle', 'MarshalByRefObject', [ 
  \ dotnet#field('safeWaitHandle', 'SafeWaitHandle'),
  \ dotnet#field('hasThreadAffinity', 'bool'),
  \ dotnet#method('WaitHandle(', ')', 'void'),
  \ dotnet#method('get_Handle(', ')', 'int'),
  \ dotnet#method('set_Handle(', 'native int value)', 'void'),
  \ dotnet#method('get_SafeWaitHandle(', ')', 'SafeWaitHandle'),
  \ dotnet#method('set_SafeWaitHandle(', 'class SafeWaitHandle value)', 'void'),
  \ dotnet#method('SetHandleInternal(', 'class SafeWaitHandle handle)', 'void'),
  \ dotnet#method('WaitOne(', 'int32 millisecondsTimeout, bool exitContext)', 'bool'),
  \ dotnet#method('WaitOne(', 'TimeSpan timeout, bool exitContext)', 'bool'),
  \ dotnet#method('WaitOne(', ')', 'bool'),
  \ dotnet#method('WaitOne(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('WaitOne(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('InternalWaitOne(', 'class SafeHandle waitableSafeHandle, int64 millisecondsTimeout, bool hasThreadAffinity, bool exitContext)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class WaitHandle[] waitHandles)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class WaitHandle[] waitHandles, int32 millisecondsTimeout)', 'static bool'),
  \ dotnet#method('WaitAll(', 'class WaitHandle[] waitHandles, TimeSpan timeout)', 'static bool'),
  \ dotnet#method('WaitAny(', 'class WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class WaitHandle[] waitHandles, TimeSpan timeout)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class WaitHandle[] waitHandles)', 'static int32'),
  \ dotnet#method('WaitAny(', 'class WaitHandle[] waitHandles, int32 millisecondsTimeout)', 'static int32'),
  \ dotnet#method('SignalAndWait(', 'class WaitHandle toSignal, WaitHandle toWaitOn)', 'static bool'),
  \ dotnet#method('SignalAndWait(', 'class WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext)', 'static bool'),
  \ dotnet#method('SignalAndWait(', 'class WaitHandle toSignal, WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext)', 'static bool'),
  \ dotnet#method('Close(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool explicitDisposing)', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('WaitHandle(', ')', 'static void .'),
  \ dotnet#prop('Handle', 'int'),
  \ dotnet#prop('SafeWaitHandle', 'SafeWaitHandle'),
  \ ])

call dotnet#class('EventWaitHandle', 'WaitHandle', [ 
  \ dotnet#method('EventWaitHandle(', 'bool initialState, EventResetMode mode)', 'void'),
  \ dotnet#method('EventWaitHandle(', 'bool initialState, EventResetMode mode, string name)', 'void'),
  \ dotnet#method('EventWaitHandle(', 'bool initialState, EventResetMode mode, string name, [out] bool& createdNew)', 'void'),
  \ dotnet#method('EventWaitHandle(', 'bool initialState, EventResetMode mode, string name, [out] bool& createdNew, EventWaitHandleSecurity eventSecurity)', 'void'),
  \ dotnet#method('OpenExisting(', 'string name)', 'static EventWaitHandle'),
  \ dotnet#method('OpenExisting(', 'string name, EventWaitHandleRights rights)', 'static EventWaitHandle'),
  \ dotnet#method('Reset(', ')', 'bool'),
  \ dotnet#method('Set(', ')', 'bool'),
  \ dotnet#method('GetAccessControl(', ')', 'EventWaitHandleSecurity'),
  \ dotnet#method('SetAccessControl(', 'class EventWaitHandleSecurity eventSecurity)', 'void'),
  \ ])

call dotnet#class('AutoResetEvent', 'EventWaitHandle', [ 
  \ dotnet#method('AutoResetEvent(', 'bool initialState)', 'void'),
  \ ])

call dotnet#class('SendOrPostCallback', 'MulticastDelegate', [ 
  \ dotnet#method('SendOrPostCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object state)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object state, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('SynchronizationContext', 'Object', [ 
  \ dotnet#method('SynchronizationContext(', ')', 'void'),
  \ dotnet#method('SetWaitNotificationRequired(', ')', 'void'),
  \ dotnet#method('IsWaitNotificationRequired(', ')', 'bool'),
  \ dotnet#method('Send(', 'class SendOrPostCallback d, object state)', 'void'),
  \ dotnet#method('Post(', 'class SendOrPostCallback d, object state)', 'void'),
  \ dotnet#method('OperationStarted(', ')', 'void'),
  \ dotnet#method('OperationCompleted(', ')', 'void'),
  \ dotnet#method('Wait(', 'native int[] waitHandles, bool waitAll, int32 millisecondsTimeout)', 'int32'),
  \ dotnet#method('WaitHelper(', 'native int[] waitHandles, bool waitAll, int32 millisecondsTimeout) internalcall', 'static int32'),
  \ dotnet#method('SetSynchronizationContext(', 'class SynchronizationContext syncContext)', 'static void'),
  \ dotnet#method('SetSynchronizationContext(', 'class SynchronizationContext syncContext, SynchronizationContext prevSyncContext)', 'static SynchronizationContextSwitcher'),
  \ dotnet#method('get_Current(', ')', 'static'),
  \ dotnet#method('CreateCopy(', ')', ''),
  \ dotnet#prop('Current', 'SynchronizationContext'),
  \ ])

call dotnet#class('CompressedStack', 'Object', [ 
  \ dotnet#field('cs', 'CompressedStack'),
  \ dotnet#field('callBack', 'ContextCallback'),
  \ dotnet#field('state', 'object'),
  \ dotnet#field('cssw', 'CompressedStackSwitcher'),
  \ dotnet#method('CompressedStack(', 'class CompressedStack cs, ContextCallback cb, object state)', 'void'),
  \ dotnet#method('get_PLS(', ')', '.method'),
  \ dotnet#method('CompressedStack(', 'class SafeCompressedStackHandle csHandle)', 'void'),
  \ dotnet#method('GetObjectData(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('get_CompressedStackHandle(', ')', '.method'),
  \ dotnet#method('set_CompressedStackHandle(', 'class SafeCompressedStackHandle value)', 'void'),
  \ dotnet#method('GetCompressedStack(', ') noinlining', 'static CompressedStack'),
  \ dotnet#method('GetCompressedStack(', 'StackCrawlMark& stackMark)', 'static CompressedStack'),
  \ dotnet#method('Capture(', ') noinlining', 'static CompressedStack'),
  \ dotnet#method('Run(', 'class CompressedStack compressedStack, ContextCallback callback, object state)', 'static reqsecobj void'),
  \ dotnet#method('runTryCode(', 'object userData)', 'static void'),
  \ dotnet#method('runFinallyCode(', 'object userData, bool exceptionThrown)', 'static void'),
  \ dotnet#method('SetCompressedStack(', 'class CompressedStack cs, CompressedStack prevCS)', 'static CompressedStackSwitcher'),
  \ dotnet#method('CreateCopy(', ')', 'CompressedStack'),
  \ dotnet#method('SetAppDomainStack(', 'class CompressedStack cs)', 'static int'),
  \ dotnet#method('RestoreAppDomainStack(', 'native int appDomainStack)', 'static void'),
  \ dotnet#method('GetCompressedStackThread(', ')', 'static CompressedStack'),
  \ dotnet#method('SetCompressedStackThread(', 'class CompressedStack cs)', 'static void'),
  \ dotnet#method('CheckDemand(', 'class CodeAccessPermission demand, PermissionToken permToken, RuntimeMethodHandleInternal rmh)', 'bool'),
  \ dotnet#method('CheckSetDemand(', 'class PermissionSet pset, RuntimeMethodHandleInternal rmh)', 'bool'),
  \ dotnet#method('DemandFlagsOrGrantSet(', 'int32 flags, PermissionSet grantSet)', 'void'),
  \ dotnet#method('GetZoneAndOrigin(', 'class ArrayList zoneList, ArrayList originList, PermissionToken zoneToken, PermissionToken originToken)', 'void'),
  \ dotnet#method('CompleteConstruction(', 'class CompressedStack innerCS)', 'void'),
  \ dotnet#method('GetDelayedCompressedStack(', 'StackCrawlMark& stackMark, bool walkStack) internalcall', 'static SafeCompressedStackHandle'),
  \ dotnet#method('DestroyDelayedCompressedStack(', 'native int unmanagedCompressedStack) internalcall', 'static void'),
  \ dotnet#method('DestroyDCSList(', 'class SafeCompressedStackHandle compressedStack) internalcall', 'static void'),
  \ dotnet#method('GetDCSCount(', 'class SafeCompressedStackHandle compressedStack) internalcall', 'static int32'),
  \ dotnet#method('IsImmediateCompletionCandidate(', 'class SafeCompressedStackHandle compressedStack, [out] CompressedStack& innerCS) internalcall', 'static bool'),
  \ dotnet#method('GetDomainCompressedStack(', 'class SafeCompressedStackHandle compressedStack, int32 index) internalcall', 'static DomainCompressedStack'),
  \ dotnet#method('GetHomogeneousPLS(', 'class PermissionListSet hgPLS) internalcall', 'static void'),
  \ dotnet#prop('PLS', 'PermissionListSet'),
  \ dotnet#prop('CompressedStackHandle', 'SafeCompressedStackHandle'),
  \ ])

call dotnet#class('AsyncFlowControl', 'ValueType', [ 
  \ dotnet#field('useEC', 'bool'),
  \ dotnet#field('_ec', 'ExecutionContext'),
  \ dotnet#field('_sc', 'SecurityContext'),
  \ dotnet#field('_thread', 'Thread'),
  \ dotnet#method('Setup(', 'SecurityContextDisableFlow flags)', 'void'),
  \ dotnet#method('Setup(', ')', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Undo(', ')', 'void'),
  \ dotnet#method('GetHashCode(', ')', 'int32'),
  \ dotnet#method('Equals(', 'object obj)', 'bool'),
  \ dotnet#method('Equals(', 'AsyncFlowControl obj)', 'bool'),
  \ dotnet#method('op_Equality(', 'AsyncFlowControl a, AsyncFlowControl b)', 'static bool'),
  \ dotnet#method('op_Inequality(', 'AsyncFlowControl a, AsyncFlowControl b)', 'static bool'),
  \ ])

call dotnet#class('ContextCallback', 'MulticastDelegate', [ 
  \ dotnet#method('ContextCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object state)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object state, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('ExecutionContext', 'Object', [ 
  \ dotnet#field('ec', 'ExecutionContext'),
  \ dotnet#field('callBack', 'ContextCallback'),
  \ dotnet#field('state', 'object'),
  \ dotnet#field('ecsw', 'ExecutionContextSwitcher'),
  \ dotnet#method('ExecutionContext(', 'class ExecutionContext executionContext, ContextCallback cb, object state)', 'void'),
  \ dotnet#field('value__', 'int32'),
  \ dotnet#field('isNewCapture', 'bool'),
  \ dotnet#field('isFlowSuppressed', 'bool'),
  \ dotnet#method('ExecutionContext(', ')', 'void'),
  \ dotnet#method('get_LogicalCallContext(', ')', '.method'),
  \ dotnet#method('set_LogicalCallContext(', 'class LogicalCallContext value)', 'void'),
  \ dotnet#method('get_IllogicalCallContext(', ')', '.method'),
  \ dotnet#method('set_IllogicalCallContext(', 'class IllogicalCallContext value)', 'void'),
  \ dotnet#method('set_Thread(', 'class Thread value)', 'void'),
  \ dotnet#method('get_SynchronizationContext(', ')', '.method'),
  \ dotnet#method('set_SynchronizationContext(', 'class SynchronizationContext value)', 'void'),
  \ dotnet#method('get_HostExecutionContext(', ')', '.method'),
  \ dotnet#method('set_HostExecutionContext(', 'class HostExecutionContext value)', 'void'),
  \ dotnet#method('get_SecurityContext(', ')', '.method'),
  \ dotnet#method('set_SecurityContext(', 'class SecurityContext value)', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Run(', 'class ExecutionContext executionContext, ContextCallback callback, object state)', 'static reqsecobj void'),
  \ dotnet#method('Run(', 'class ExecutionContext executionContext, ContextCallback callback, object state, bool ignoreSyncCtx)', 'static reqsecobj void'),
  \ dotnet#method('RunInternal(', 'class ExecutionContext executionContext, ContextCallback callback, object state)', 'static void'),
  \ dotnet#method('runTryCode(', 'object userData)', 'static void'),
  \ dotnet#method('runFinallyCode(', 'object userData, bool exceptionThrown)', 'static void'),
  \ dotnet#method('SetExecutionContext(', 'class ExecutionContext executionContext) noinlining', 'static reqsecobj'),
  \ dotnet#method('CreateCopy(', ')', 'ExecutionContext'),
  \ dotnet#method('SuppressFlow(', ')', 'static AsyncFlowControl'),
  \ dotnet#method('RestoreFlow(', ')', 'static void'),
  \ dotnet#method('IsFlowSuppressed(', ')', 'static bool'),
  \ dotnet#method('Capture(', ') noinlining', 'static ExecutionContext'),
  \ dotnet#method('Capture(', 'StackCrawlMark& stackMark, ExecutionContext/CaptureOptions options)', 'static ExecutionContext'),
  \ dotnet#method('GetObjectData(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('IsDefaultFTContext(', 'bool ignoreSyncCtx)', 'bool'),
  \ dotnet#method('ExecutionContext(', ')', 'static void .'),
  \ dotnet#prop('LogicalCallContext', 'LogicalCallContext'),
  \ dotnet#prop('IllogicalCallContext', 'IllogicalCallContext'),
  \ dotnet#prop('Thread', 'Thread'),
  \ dotnet#prop('SynchronizationContext', 'SynchronizationContext'),
  \ dotnet#prop('HostExecutionContext', 'HostExecutionContext'),
  \ dotnet#prop('SecurityContext', 'SecurityContext'),
  \ ])

call dotnet#class('Interlocked', 'Object', [ 
  \ dotnet#method('Increment(', 'int32& location)', 'static int32'),
  \ dotnet#method('Increment(', 'int64& location)', 'static int64'),
  \ dotnet#method('Decrement(', 'int32& location)', 'static int32'),
  \ dotnet#method('Decrement(', 'int64& location)', 'static int64'),
  \ dotnet#method('Exchange(', 'int32& location1, int32 value) internalcall', 'static int32'),
  \ dotnet#method('Exchange(', 'int64& location1, int64 value) internalcall', 'static int64'),
  \ dotnet#method('Exchange(', 'float32& location1, float32 value) internalcall', 'static float32'),
  \ dotnet#method('Exchange(', 'float64& location1, float64 value) internalcall', 'static float64'),
  \ dotnet#method('Exchange(', 'object& location1, object value) internalcall', 'static object'),
  \ dotnet#method('Exchange(', 'native int& location1, int value) internalcall', 'static int'),
  \ dotnet#method('Exchange(', '!!T& location1, !!T value)', 'static !!T'),
  \ dotnet#method('CompareExchange(', 'int32& location1, int32 value, int32 comparand) internalcall', 'static int32'),
  \ dotnet#method('CompareExchange(', 'int64& location1, int64 value, int64 comparand) internalcall', 'static int64'),
  \ dotnet#method('CompareExchange(', 'float32& location1, float32 value, float32 comparand) internalcall', 'static float32'),
  \ dotnet#method('CompareExchange(', 'float64& location1, float64 value, float64 comparand) internalcall', 'static float64'),
  \ dotnet#method('CompareExchange(', 'object& location1, object value, object comparand) internalcall', 'static object'),
  \ dotnet#method('CompareExchange(', 'native int& location1, int value, int comparand) internalcall', 'static int'),
  \ dotnet#method('CompareExchange(', '!!T& location1, !!T value, !!T comparand)', 'static !!T'),
  \ dotnet#method('CompareExchange(', 'int32& location1, int32 value, int32 comparand, bool& succeeded) internalcall', 'static int32'),
  \ dotnet#method('ExchangeAdd(', 'int32& location1, int32 value) internalcall', 'static int32'),
  \ dotnet#method('ExchangeAdd(', 'int64& location1, int64 value) internalcall', 'static int64'),
  \ dotnet#method('Add(', 'int32& location1, int32 value)', 'static int32'),
  \ dotnet#method('Add(', 'int64& location1, int64 value)', 'static int64'),
  \ dotnet#method('Read(', 'int64& location)', 'static int64'),
  \ ])

call dotnet#class('HostExecutionContext', 'Object', [ 
  \ dotnet#method('get_State(', ')', 'famorassem object'),
  \ dotnet#method('set_State(', 'object value)', 'famorassem void'),
  \ dotnet#method('HostExecutionContext(', ')', 'void'),
  \ dotnet#method('HostExecutionContext(', 'object state)', 'void'),
  \ dotnet#method('CreateCopy(', ')', ''),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#prop('State', 'object'),
  \ ])

call dotnet#class('HostExecutionContextManager', 'Object', [ 
  \ dotnet#method('ReleaseHostSecurityContext(', 'native int context) internalcall', 'static int32'),
  \ dotnet#method('CloneHostSecurityContext(', 'class SafeHandle context, SafeHandle clonedContext) internalcall', 'static int32'),
  \ dotnet#method('CheckIfHosted(', ')', 'static bool'),
  \ dotnet#method('Capture(', ')', ''),
  \ dotnet#method('SetHostExecutionContext(', 'class HostExecutionContext hostExecutionContext)', 'object'),
  \ dotnet#method('Revert(', 'object previousState)', 'void'),
  \ dotnet#method('CaptureHostExecutionContext(', ')', 'static HostExecutionContext'),
  \ dotnet#method('SetHostExecutionContextInternal(', 'class HostExecutionContext hostContext)', 'static object'),
  \ dotnet#method('GetCurrentHostExecutionContextManager(', ')', 'static HostExecutionContextManager'),
  \ dotnet#method('GetInternalHostExecutionContextManager(', ')', 'static HostExecutionContextManager'),
  \ dotnet#method('HostExecutionContextManager(', ')', 'void'),
  \ ])

call dotnet#class('LockCookie', 'ValueType', [ 
  \ dotnet#field('_dwFlags', 'int32'),
  \ dotnet#field('_dwWriterSeqNum', 'int32'),
  \ dotnet#field('_wReaderAndWriterLevel', 'int32'),
  \ dotnet#field('_dwThreadID', 'int32'),
  \ dotnet#method('GetHashCode(', ')', 'int32'),
  \ dotnet#method('Equals(', 'object obj)', 'bool'),
  \ dotnet#method('Equals(', 'LockCookie obj)', 'bool'),
  \ dotnet#method('op_Equality(', 'LockCookie a, LockCookie b)', 'static bool'),
  \ dotnet#method('op_Inequality(', 'LockCookie a, LockCookie b)', 'static bool'),
  \ ])

call dotnet#class('LockRecursionException', 'Exception', [ 
  \ dotnet#method('LockRecursionException(', ')', 'void'),
  \ dotnet#method('LockRecursionException(', 'string message)', 'void'),
  \ dotnet#method('LockRecursionException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('LockRecursionException(', 'string message, Exception innerException)', 'void'),
  \ ])

call dotnet#class('ManualResetEvent', 'EventWaitHandle', [ 
  \ dotnet#method('ManualResetEvent(', 'bool initialState)', 'void'),
  \ ])

call dotnet#class('Monitor', 'Object', [ 
  \ dotnet#method('Enter(', 'object obj) internalcall', 'static void'),
  \ dotnet#method('Enter(', 'object obj, bool& lockTaken)', 'static void'),
  \ dotnet#method('Exit(', 'object obj) internalcall', 'static void'),
  \ dotnet#method('TryEnter(', 'object obj)', 'static bool'),
  \ dotnet#method('TryEnter(', 'object obj, bool& lockTaken)', 'static void'),
  \ dotnet#method('TryEnter(', 'object obj, int32 millisecondsTimeout)', 'static bool'),
  \ dotnet#method('TryEnter(', 'object obj, TimeSpan timeout)', 'static bool'),
  \ dotnet#method('TryEnter(', 'object obj, int32 millisecondsTimeout, bool& lockTaken)', 'static void'),
  \ dotnet#method('TryEnter(', 'object obj, TimeSpan timeout, bool& lockTaken)', 'static void'),
  \ dotnet#method('Wait(', 'object obj, int32 millisecondsTimeout, bool exitContext)', 'static bool'),
  \ dotnet#method('Wait(', 'object obj, TimeSpan timeout, bool exitContext)', 'static bool'),
  \ dotnet#method('Wait(', 'object obj, int32 millisecondsTimeout)', 'static bool'),
  \ dotnet#method('Wait(', 'object obj, TimeSpan timeout)', 'static bool'),
  \ dotnet#method('Wait(', 'object obj)', 'static bool'),
  \ dotnet#method('Pulse(', 'object obj)', 'static void'),
  \ dotnet#method('PulseAll(', 'object obj)', 'static void'),
  \ ])

call dotnet#class('Mutex', 'WaitHandle', [ 
  \ dotnet#field('m_newMutex', 'bool'),
  \ dotnet#method('Mutex(', 'bool initiallyOwned, Mutex/MutexCleanupInfo cleanupInfo, string name, Win32Native/SECURITY_ATTRIBUTES secAttrs, Mutex mutex)', 'void'),
  \ dotnet#method('MutexTryCode(', 'object userData)', 'void'),
  \ dotnet#field('mutexHandle', 'SafeWaitHandle'),
  \ dotnet#field('inCriticalRegion', 'bool'),
  \ dotnet#method('Mutex(', 'class SafeWaitHandle mutexHandle, bool inCriticalRegion)', 'void'),
  \ dotnet#method('Mutex(', 'bool initiallyOwned, string name, [out] bool& createdNew)', 'void'),
  \ dotnet#method('Mutex(', 'bool initiallyOwned, string name, [out] bool& createdNew, MutexSecurity mutexSecurity)', 'void'),
  \ dotnet#method('Mutex(', 'bool initiallyOwned, string name)', 'void'),
  \ dotnet#method('Mutex(', 'bool initiallyOwned)', 'void'),
  \ dotnet#method('Mutex(', ')', 'void'),
  \ dotnet#method('OpenExisting(', 'string name)', 'static Mutex'),
  \ dotnet#method('OpenExisting(', 'string name, MutexRights rights)', 'static Mutex'),
  \ dotnet#method('ReleaseMutex(', ')', 'void'),
  \ dotnet#method('GetAccessControl(', ')', 'MutexSecurity'),
  \ dotnet#method('SetAccessControl(', 'class MutexSecurity mutexSecurity)', 'void'),
  \ dotnet#method('AcquireReservedMutex(', 'bool& bHandleObtained)', 'static void'),
  \ dotnet#method('ReleaseReservedMutex(', ')', 'static void'),
  \ dotnet#method('Mutex(', ')', 'static void .'),
  \ ])

call dotnet#class('NativeOverlapped', 'ValueType', [ 
  \ dotnet#field('InternalLow', 'int'),
  \ dotnet#field('InternalHigh', 'int'),
  \ dotnet#field('OffsetLow', 'int32'),
  \ dotnet#field('OffsetHigh', 'int32'),
  \ dotnet#field('EventHandle', 'int'),
  \ ])

call dotnet#class('Overlapped', 'Object', [ 
  \ dotnet#method('Overlapped(', ')', 'void'),
  \ dotnet#method('Overlapped(', 'int32 offsetLo, int32 offsetHi, int hEvent, IAsyncResult ar)', 'void'),
  \ dotnet#method('Overlapped(', 'int32 offsetLo, int32 offsetHi, int32 hEvent, IAsyncResult ar)', 'void'),
  \ dotnet#method('get_AsyncResult(', ')', 'IAsyncResult'),
  \ dotnet#method('set_AsyncResult(', 'class IAsyncResult value)', 'void'),
  \ dotnet#method('get_OffsetLow(', ')', 'int32'),
  \ dotnet#method('set_OffsetLow(', 'int32 value)', 'void'),
  \ dotnet#method('get_OffsetHigh(', ')', 'int32'),
  \ dotnet#method('set_OffsetHigh(', 'int32 value)', 'void'),
  \ dotnet#method('get_EventHandle(', ')', 'int32'),
  \ dotnet#method('set_EventHandle(', 'int32 value)', 'void'),
  \ dotnet#method('get_EventHandleIntPtr(', ')', 'int'),
  \ dotnet#method('set_EventHandleIntPtr(', 'native int value)', 'void'),
  \ dotnet#method('get_iocbHelper(', ')', '.method'),
  \ dotnet#method('get_UserCallback(', ')', '.method'),
  \ dotnet#method('Pack(', 'class IOCompletionCallback iocb)', 'NativeOverlapped*'),
  \ dotnet#method('Pack(', 'class IOCompletionCallback iocb, object userData)', 'NativeOverlapped*'),
  \ dotnet#method('UnsafePack(', 'class IOCompletionCallback iocb)', 'NativeOverlapped*'),
  \ dotnet#method('UnsafePack(', 'class IOCompletionCallback iocb, object userData)', 'NativeOverlapped*'),
  \ dotnet#method('Unpack(', 'NativeOverlapped* nativeOverlappedPtr)', 'static Overlapped'),
  \ dotnet#method('Free(', 'NativeOverlapped* nativeOverlappedPtr)', 'static void'),
  \ dotnet#prop('AsyncResult', 'IAsyncResult'),
  \ dotnet#prop('OffsetLow', 'int32'),
  \ dotnet#prop('OffsetHigh', 'int32'),
  \ dotnet#prop('EventHandle', 'int32'),
  \ dotnet#prop('EventHandleIntPtr', 'int'),
  \ dotnet#prop('iocbHelper', '_IOCompletionCallback'),
  \ dotnet#prop('UserCallback', 'IOCompletionCallback'),
  \ ])

call dotnet#class('ParameterizedThreadStart', 'MulticastDelegate', [ 
  \ dotnet#method('ParameterizedThreadStart(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object obj)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object obj, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('ReaderWriterLock', 'CriticalFinalizerObject', [ 
  \ dotnet#method('ReaderWriterLock(', ')', 'void'),
  \ dotnet#method('Finalize(', ')', 'void'),
  \ dotnet#method('get_IsReaderLockHeld(', ')', 'bool'),
  \ dotnet#method('get_IsWriterLockHeld(', ')', 'bool'),
  \ dotnet#method('get_WriterSeqNum(', ')', 'int32'),
  \ dotnet#method('AcquireReaderLock(', 'int32 millisecondsTimeout)', 'void'),
  \ dotnet#method('AcquireReaderLock(', 'TimeSpan timeout)', 'void'),
  \ dotnet#method('AcquireWriterLock(', 'int32 millisecondsTimeout)', 'void'),
  \ dotnet#method('AcquireWriterLock(', 'TimeSpan timeout)', 'void'),
  \ dotnet#method('ReleaseReaderLock(', ')', 'void'),
  \ dotnet#method('ReleaseWriterLock(', ')', 'void'),
  \ dotnet#method('UpgradeToWriterLock(', 'int32 millisecondsTimeout)', 'LockCookie'),
  \ dotnet#method('UpgradeToWriterLock(', 'TimeSpan timeout)', 'LockCookie'),
  \ dotnet#method('DowngradeFromWriterLock(', 'LockCookie& lockCookie)', 'void'),
  \ dotnet#method('ReleaseLock(', ')', 'LockCookie'),
  \ dotnet#method('RestoreLock(', 'LockCookie& lockCookie)', 'void'),
  \ dotnet#method('AnyWritersSince(', 'int32 seqNum) internalcall', 'bool'),
  \ dotnet#prop('IsReaderLockHeld', 'bool'),
  \ dotnet#prop('IsWriterLockHeld', 'bool'),
  \ dotnet#prop('WriterSeqNum', 'int32'),
  \ ])

call dotnet#class('SemaphoreFullException', 'SystemException', [ 
  \ dotnet#method('SemaphoreFullException(', ')', 'void'),
  \ dotnet#method('SemaphoreFullException(', 'string message)', 'void'),
  \ dotnet#method('SemaphoreFullException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('SemaphoreFullException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('SynchronizationLockException', 'SystemException', [ 
  \ dotnet#method('SynchronizationLockException(', ')', 'void'),
  \ dotnet#method('SynchronizationLockException(', 'string message)', 'void'),
  \ dotnet#method('SynchronizationLockException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('SynchronizationLockException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('Thread', 'CriticalFinalizerObject', [ 
  \ dotnet#method('Thread(', 'class ThreadStart start)', 'void'),
  \ dotnet#method('Thread(', 'class ThreadStart start, int32 maxStackSize)', 'void'),
  \ dotnet#method('Thread(', 'class ParameterizedThreadStart start)', 'void'),
  \ dotnet#method('Thread(', 'class ParameterizedThreadStart start, int32 maxStackSize)', 'void'),
  \ dotnet#method('GetHashCode(', ')', 'int32'),
  \ dotnet#method('get_ManagedThreadId(', ') internalcall', 'int32'),
  \ dotnet#method('GetNativeHandle(', ')', 'ThreadHandle'),
  \ dotnet#method('Start(', ') noinlining', 'void'),
  \ dotnet#method('Start(', 'object parameter) noinlining', 'void'),
  \ dotnet#method('GetExecutionContextNoCreate(', ')', 'ExecutionContext'),
  \ dotnet#method('get_ExecutionContext(', ')', 'ExecutionContext'),
  \ dotnet#method('SetExecutionContext(', 'class ExecutionContext value)', 'void'),
  \ dotnet#method('SetCompressedStack(', 'class CompressedStack stack)', 'reqsecobj void'),
  \ dotnet#method('SetAppDomainStack(', 'class SafeCompressedStackHandle csHandle) internalcall', 'int'),
  \ dotnet#method('RestoreAppDomainStack(', 'native int appDomainStack) internalcall', 'void'),
  \ dotnet#method('GetCompressedStack(', ')', 'CompressedStack'),
  \ dotnet#method('InternalGetCurrentThread(', ') internalcall', 'static int'),
  \ dotnet#method('Abort(', 'object stateInfo)', 'void'),
  \ dotnet#method('Abort(', ')', 'void'),
  \ dotnet#method('ResetAbort(', ')', 'static void'),
  \ dotnet#method('Suspend(', ')', 'void'),
  \ dotnet#method('Resume(', ')', 'void'),
  \ dotnet#method('Interrupt(', ')', 'void'),
  \ dotnet#method('get_Priority(', ')', 'ThreadPriority'),
  \ dotnet#method('set_Priority(', 'ThreadPriority value)', 'void'),
  \ dotnet#method('get_IsAlive(', ')', 'bool'),
  \ dotnet#method('get_IsThreadPoolThread(', ')', 'bool'),
  \ dotnet#method('Join(', ')', 'void'),
  \ dotnet#method('Join(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('Join(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('Sleep(', 'int32 millisecondsTimeout)', 'static void'),
  \ dotnet#method('Sleep(', 'TimeSpan timeout)', 'static void'),
  \ dotnet#method('SpinWait(', 'int32 iterations) linkcheck', 'static void'),
  \ dotnet#method('Yield(', ') linkcheck', 'static bool'),
  \ dotnet#method('get_CurrentThread(', ')', 'static Thread'),
  \ dotnet#method('Finalize(', ')', 'void'),
  \ dotnet#method('DisableComObjectEagerCleanup(', ') internalcall', 'void'),
  \ dotnet#method('get_IsBackground(', ')', 'bool'),
  \ dotnet#method('set_IsBackground(', 'bool value)', 'void'),
  \ dotnet#method('get_ThreadState(', ')', 'ThreadState'),
  \ dotnet#method('get_ApartmentState(', ')', 'ApartmentState'),
  \ dotnet#method('set_ApartmentState(', 'ApartmentState value)', 'void'),
  \ dotnet#method('GetApartmentState(', ')', 'ApartmentState'),
  \ dotnet#method('TrySetApartmentState(', 'ApartmentState state)', 'bool'),
  \ dotnet#method('SetApartmentState(', 'ApartmentState state)', 'void'),
  \ dotnet#method('AllocateDataSlot(', ')', 'static LocalDataStoreSlot'),
  \ dotnet#method('AllocateNamedDataSlot(', 'string name)', 'static LocalDataStoreSlot'),
  \ dotnet#method('GetNamedDataSlot(', 'string name)', 'static LocalDataStoreSlot'),
  \ dotnet#method('FreeNamedDataSlot(', 'string name) linkcheck', 'static void'),
  \ dotnet#method('GetData(', 'class LocalDataStoreSlot slot)', 'static object'),
  \ dotnet#method('SetData(', 'class LocalDataStoreSlot slot, object data)', 'static void'),
  \ dotnet#method('get_CurrentUICulture(', ')', 'CultureInfo'),
  \ dotnet#method('set_CurrentUICulture(', 'class CultureInfo value)', 'void'),
  \ dotnet#method('get_CurrentCulture(', ')', 'CultureInfo'),
  \ dotnet#method('set_CurrentCulture(', 'class CultureInfo value)', 'void'),
  \ dotnet#method('get_CurrentContext(', ')', 'static'),
  \ dotnet#method('GetCurrentContextInternal(', ')', 'Context'),
  \ dotnet#method('GetLogicalCallContext(', ')', 'LogicalCallContext'),
  \ dotnet#method('SetLogicalCallContext(', 'class LogicalCallContext callCtx)', 'LogicalCallContext'),
  \ dotnet#method('GetIllogicalCallContext(', ')', 'IllogicalCallContext'),
  \ dotnet#method('get_CurrentPrincipal(', ')', 'static'),
  \ dotnet#method('set_CurrentPrincipal(', 'class IPrincipal value)', 'static void'),
  \ dotnet#method('GetContextInternal(', 'native int id) internalcall', 'static Context'),
  \ dotnet#method('InternalCrossContextCallback(', 'class Context ctx, int ctxID, int32 appDomainID, InternalCrossContextDelegate ftnToCall, object[] args) internalcall', 'object'),
  \ dotnet#method('InternalCrossContextCallback(', 'class Context ctx, InternalCrossContextDelegate ftnToCall, object[] args)', 'object'),
  \ dotnet#method('GetDomain(', ')', 'static AppDomain'),
  \ dotnet#method('GetDomainID(', ')', 'static int32'),
  \ dotnet#method('get_Name(', ')', 'string'),
  \ dotnet#method('set_Name(', 'string value)', 'void'),
  \ dotnet#method('get_AbortReason(', ')', 'object'),
  \ dotnet#method('set_AbortReason(', 'object value)', 'void'),
  \ dotnet#method('BeginCriticalRegion(', ') internalcall linkcheck', 'static void'),
  \ dotnet#method('EndCriticalRegion(', ') internalcall linkcheck', 'static void'),
  \ dotnet#method('BeginThreadAffinity(', ') internalcall', 'static void'),
  \ dotnet#method('EndThreadAffinity(', ') internalcall', 'static void'),
  \ dotnet#method('VolatileRead(', 'uint8& address) noinlining', 'static uint8'),
  \ dotnet#method('VolatileRead(', 'int16& address) noinlining', 'static int16'),
  \ dotnet#method('VolatileRead(', 'int32& address) noinlining', 'static int32'),
  \ dotnet#method('VolatileRead(', 'int64& address) noinlining', 'static int64'),
  \ dotnet#method('VolatileRead(', 'int8& address) noinlining', 'static int8'),
  \ dotnet#method('VolatileRead(', 'uint16& address) noinlining', 'static uint16'),
  \ dotnet#method('VolatileRead(', 'uint32& address) noinlining', 'static uint32'),
  \ dotnet#method('VolatileRead(', 'native int& address) noinlining', 'static int'),
  \ dotnet#method('VolatileRead(', 'native uint& address) noinlining', 'static uint'),
  \ dotnet#method('VolatileRead(', 'uint64& address) noinlining', 'static uint64'),
  \ dotnet#method('VolatileRead(', 'float32& address) noinlining', 'static float32'),
  \ dotnet#method('VolatileRead(', 'float64& address) noinlining', 'static float64'),
  \ dotnet#method('VolatileRead(', 'object& address) noinlining', 'static object'),
  \ dotnet#method('VolatileWrite(', 'uint8& address, uint8 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'int16& address, int16 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'int32& address, int32 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'int64& address, int64 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'int8& address, int8 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'uint16& address, uint16 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'uint32& address, uint32 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'native int& address, int value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'native uint& address, uint value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'uint64& address, uint64 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'float32& address, float32 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'float64& address, float64 value) noinlining', 'static void'),
  \ dotnet#method('VolatileWrite(', 'object& address, object value) noinlining', 'static void'),
  \ dotnet#method('MemoryBarrier(', ') internalcall', 'static void'),
  \ dotnet#method('GetTypeInfoCount(', '[out] uint32& pcTInfo)', 'void '),
  \ dotnet#method('GetTypeInfo(', 'uint32 iTInfo, uint32 lcid, int ppTInfo)', 'void '),
  \ dotnet#method('GetIDsOfNames(', '[in] Guid& riid, int rgszNames, uint32 cNames, uint32 lcid, int rgDispId)', 'void '),
  \ dotnet#method('Invoke(', 'uint32 dispIdMember, [in] Guid& riid, uint32 lcid, int16 wFlags, int pDispParams, int pVarResult, int pExcepInfo, int puArgErr)', 'void '),
  \ dotnet#method('SetAbortReason(', 'object o) internalcall', 'void'),
  \ dotnet#method('GetAbortReason(', ') internalcall', 'object'),
  \ dotnet#method('ClearAbortReason(', ') internalcall', 'void'),
  \ dotnet#prop('ManagedThreadId', 'int32'),
  \ dotnet#prop('ExecutionContext', 'ExecutionContext'),
  \ dotnet#prop('Priority', 'ThreadPriority'),
  \ dotnet#prop('IsAlive', 'bool'),
  \ dotnet#prop('IsThreadPoolThread', 'bool'),
  \ dotnet#prop('CurrentThread', 'Thread'),
  \ dotnet#prop('IsBackground', 'bool'),
  \ dotnet#prop('ThreadState', 'ThreadState'),
  \ dotnet#prop('ApartmentState', 'ApartmentState'),
  \ dotnet#prop('CurrentUICulture', 'CultureInfo'),
  \ dotnet#prop('CurrentCulture', 'CultureInfo'),
  \ dotnet#prop('CurrentContext', 'Context'),
  \ dotnet#prop('CurrentPrincipal', 'IPrincipal'),
  \ dotnet#prop('Name', 'string'),
  \ dotnet#prop('AbortReason', 'object'),
  \ ])

call dotnet#class('ThreadAbortException', 'SystemException', [ 
  \ dotnet#method('ThreadAbortException(', ')', 'void'),
  \ dotnet#method('ThreadAbortException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ dotnet#method('get_ExceptionState(', ')', 'object'),
  \ dotnet#prop('ExceptionState', 'object'),
  \ ])

call dotnet#class('ThreadInterruptedException', 'SystemException', [ 
  \ dotnet#method('ThreadInterruptedException(', ')', 'void'),
  \ dotnet#method('ThreadInterruptedException(', 'string message)', 'void'),
  \ dotnet#method('ThreadInterruptedException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('ThreadInterruptedException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('RegisteredWaitHandle', 'MarshalByRefObject', [ 
  \ dotnet#method('RegisteredWaitHandle(', ')', 'void'),
  \ dotnet#method('SetHandle(', 'native int handle)', 'void'),
  \ dotnet#method('SetWaitObject(', 'class WaitHandle waitObject)', 'void'),
  \ dotnet#method('Unregister(', 'class WaitHandle waitObject)', 'bool'),
  \ ])

call dotnet#class('WaitCallback', 'MulticastDelegate', [ 
  \ dotnet#method('WaitCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object state)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object state, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('WaitOrTimerCallback', 'MulticastDelegate', [ 
  \ dotnet#method('WaitOrTimerCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object state, bool timedOut)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object state, bool timedOut, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('IOCompletionCallback', 'MulticastDelegate', [ 
  \ dotnet#method('IOCompletionCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'uint32 errorCode, uint32 numBytes, NativeOverlapped* pOVERLAP)', 'void'),
  \ dotnet#method('BeginInvoke(', 'uint32 errorCode, uint32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('ThreadPool', 'Object', [ 
  \ dotnet#method('SetMaxThreads(', 'int32 workerThreads, int32 completionPortThreads)', 'static bool'),
  \ dotnet#method('GetMaxThreads(', '[out] int32& workerThreads, [out] int32& completionPortThreads)', 'static void'),
  \ dotnet#method('SetMinThreads(', 'int32 workerThreads, int32 completionPortThreads)', 'static bool'),
  \ dotnet#method('GetMinThreads(', '[out] int32& workerThreads, [out] int32& completionPortThreads)', 'static void'),
  \ dotnet#method('GetAvailableThreads(', '[out] int32& workerThreads, [out] int32& completionPortThreads)', 'static void'),
  \ dotnet#method('RegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint32 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('UnsafeRegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint32 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('RegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('UnsafeRegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('RegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('UnsafeRegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('RegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('UnsafeRegisterWaitForSingleObject(', 'class WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce) noinlining', 'static RegisteredWaitHandle'),
  \ dotnet#method('QueueUserWorkItem(', 'class WaitCallback callBack, object state) noinlining', 'static bool'),
  \ dotnet#method('QueueUserWorkItem(', 'class WaitCallback callBack) noinlining', 'static bool'),
  \ dotnet#method('UnsafeQueueUserWorkItem(', 'class WaitCallback callBack, object state) noinlining', 'static bool'),
  \ dotnet#method('UnsafeQueueCustomWorkItem(', 'class IThreadPoolWorkItem workItem, bool forceGlobal)', 'static void'),
  \ dotnet#method('TryPopCustomWorkItem(', 'class IThreadPoolWorkItem workItem)', 'static bool'),
  \ dotnet#method('GetQueuedWorkItems(', ')', 'static IEnumerable'),
  \ dotnet#method('EnumerateQueuedWorkItems(', 'class ThreadPoolWorkQueue/WorkStealingQueue[] wsQueues, ThreadPoolWorkQueue/QueueSegment globalQueueTail)', 'static IEnumerable'),
  \ dotnet#method('GetLocallyQueuedWorkItems(', ')', 'static IEnumerable'),
  \ dotnet#method('GetGloballyQueuedWorkItems(', ')', 'static IEnumerable'),
  \ dotnet#method('GetQueuedWorkItemsForDebugger(', ')', 'static object[]'),
  \ dotnet#method('GetGloballyQueuedWorkItemsForDebugger(', ')', 'static object[]'),
  \ dotnet#method('GetLocallyQueuedWorkItemsForDebugger(', ')', 'static object[]'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) bool AdjustThreadsInPool(uint32 QueueLength) preservesig', 'static'),
  \ dotnet#method('UnsafeQueueNativeOverlapped(', 'NativeOverlapped* overlapped)', 'static bool'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) bool ShouldUseNewWorkerPool() preservesig', 'static'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) bool CompleteThreadPoolRequest(uint32 QueueLength) preservesig', 'static'),
  \ dotnet#method('NotifyWorkItemComplete(', ') internalcall', 'static bool'),
  \ dotnet#method('ReportThreadStatus(', 'bool isWorking) internalcall', 'static void'),
  \ dotnet#method('NotifyWorkItemProgress(', ')', 'static void'),
  \ dotnet#method('NotifyWorkItemProgressNative(', ') internalcall', 'static void'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) bool ShouldReturnToVm() preservesig', 'static'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) bool SetAppDomainRequestActive() preservesig', 'static'),
  \ dotnet#method('pinvokeimpl(', '"QCall" unicode winapi) void ClearAppDomainRequestActive() preservesig', 'static'),
  \ dotnet#method('IsThreadPoolHosted(', ') internalcall', 'static bool'),
  \ dotnet#method('SetNativeTpEvent(', ') internalcall', 'static void'),
  \ dotnet#method('BindHandle(', 'native int osHandle)', 'static bool'),
  \ dotnet#method('BindHandle(', 'class SafeHandle osHandle)', 'static bool'),
  \ ])

call dotnet#class('ThreadStart', 'MulticastDelegate', [ 
  \ dotnet#method('ThreadStart(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', ')', 'void'),
  \ dotnet#method('BeginInvoke(', 'class AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('ThreadStateException', 'SystemException', [ 
  \ dotnet#method('ThreadStateException(', ')', 'void'),
  \ dotnet#method('ThreadStateException(', 'string message)', 'void'),
  \ dotnet#method('ThreadStateException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('ThreadStateException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('ThreadStartException', 'SystemException', [ 
  \ dotnet#method('ThreadStartException(', ')', 'void'),
  \ dotnet#method('ThreadStartException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('Timeout', 'Object', [ 
  \ ])

call dotnet#class('TimerCallback', 'MulticastDelegate', [ 
  \ dotnet#method('TimerCallback(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object state)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object state, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

call dotnet#class('Timer', 'MarshalByRefObject', [ 
  \ dotnet#method('Timer(', 'class TimerCallback callback, object state, int32 dueTime, int32 period) noinlining', 'void'),
  \ dotnet#method('Timer(', 'class TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period) noinlining', 'void'),
  \ dotnet#method('Timer(', 'class TimerCallback callback, object state, uint32 dueTime, uint32 period) noinlining', 'void'),
  \ dotnet#method('Timer(', 'class TimerCallback callback, object state, int64 dueTime, int64 period) noinlining', 'void'),
  \ dotnet#method('Timer(', 'class TimerCallback callback) noinlining', 'void'),
  \ dotnet#method('Change(', 'int32 dueTime, int32 period)', 'bool'),
  \ dotnet#method('Change(', 'TimeSpan dueTime, TimeSpan period)', 'bool'),
  \ dotnet#method('Change(', 'uint32 dueTime, uint32 period)', 'bool'),
  \ dotnet#method('Change(', 'int64 dueTime, int64 period)', 'bool'),
  \ dotnet#method('Dispose(', 'class WaitHandle notifyObject)', 'bool'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ ])

call dotnet#class('WaitHandleCannotBeOpenedException', 'ApplicationException', [ 
  \ dotnet#method('WaitHandleCannotBeOpenedException(', ')', 'void'),
  \ dotnet#method('WaitHandleCannotBeOpenedException(', 'string message)', 'void'),
  \ dotnet#method('WaitHandleCannotBeOpenedException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('WaitHandleCannotBeOpenedException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('SpinLock', 'ValueType', [ 
  \ dotnet#method('SpinLock(', 'SpinLock spinLock)', 'void'),
  \ dotnet#method('get_IsHeldByCurrentThread(', ')', ''),
  \ dotnet#method('get_OwnerThreadID(', ')', ''),
  \ dotnet#method('get_IsHeld(', ')', 'bool'),
  \ dotnet#prop('IsHeldByCurrentThread', 'Nullable'),
  \ dotnet#prop('OwnerThreadID', 'Nullable'),
  \ dotnet#prop('IsHeld', 'bool'),
  \ dotnet#field('m_owner', 'IsVolatile)'),
  \ dotnet#method('SpinLock(', 'bool enableThreadOwnerTracking)', 'void'),
  \ dotnet#method('Enter(', 'bool& lockTaken)', 'void'),
  \ dotnet#method('TryEnter(', 'bool& lockTaken)', 'void'),
  \ dotnet#method('TryEnter(', 'TimeSpan timeout, bool& lockTaken)', 'void'),
  \ dotnet#method('TryEnter(', 'int32 millisecondsTimeout, bool& lockTaken)', 'void'),
  \ dotnet#method('Exit(', ')', 'void'),
  \ dotnet#method('Exit(', 'bool useMemoryBarrier)', 'void'),
  \ dotnet#method('get_IsHeld(', ')', 'bool'),
  \ dotnet#method('get_IsHeldByCurrentThread(', ')', 'bool'),
  \ dotnet#method('get_IsThreadOwnerTrackingEnabled(', ')', 'bool'),
  \ dotnet#method('SpinLock(', ')', 'static void .'),
  \ dotnet#prop('IsHeld', 'bool'),
  \ dotnet#prop('IsHeldByCurrentThread', 'bool'),
  \ dotnet#prop('IsThreadOwnerTrackingEnabled', 'bool'),
  \ ])

call dotnet#class('SpinWait', 'ValueType', [ 
  \ dotnet#field('m_count', 'int32'),
  \ dotnet#method('get_Count(', ')', 'int32'),
  \ dotnet#method('get_NextSpinWillYield(', ')', 'bool'),
  \ dotnet#method('SpinOnce(', ')', 'void'),
  \ dotnet#method('Reset(', ')', 'void'),
  \ dotnet#method('SpinUntil(', 'class Func condition)', 'static void'),
  \ dotnet#method('SpinUntil(', 'class Func condition, TimeSpan timeout)', 'static bool'),
  \ dotnet#method('SpinUntil(', 'class Func condition, int32 millisecondsTimeout)', 'static bool'),
  \ dotnet#prop('Count', 'int32'),
  \ dotnet#prop('NextSpinWillYield', 'bool'),
  \ ])

call dotnet#class('CountdownEvent', 'Object', [ 
  \ dotnet#method('CountdownEvent(', 'int32 initialCount)', 'void'),
  \ dotnet#method('get_CurrentCount(', ')', 'int32'),
  \ dotnet#method('get_InitialCount(', ')', 'int32'),
  \ dotnet#method('get_IsSet(', ')', 'bool'),
  \ dotnet#method('get_WaitHandle(', ')', 'WaitHandle'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#method('Signal(', ')', 'bool'),
  \ dotnet#method('Signal(', 'int32 signalCount)', 'bool'),
  \ dotnet#method('AddCount(', ')', 'void'),
  \ dotnet#method('TryAddCount(', ')', 'bool'),
  \ dotnet#method('AddCount(', 'int32 signalCount)', 'void'),
  \ dotnet#method('TryAddCount(', 'int32 signalCount)', 'bool'),
  \ dotnet#method('Reset(', ')', 'void'),
  \ dotnet#method('Reset(', 'int32 count)', 'void'),
  \ dotnet#method('Wait(', ')', 'void'),
  \ dotnet#method('Wait(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('Wait(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('Wait(', 'TimeSpan timeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#prop('CurrentCount', 'int32'),
  \ dotnet#prop('InitialCount', 'int32'),
  \ dotnet#prop('IsSet', 'bool'),
  \ dotnet#prop('WaitHandle', 'WaitHandle'),
  \ ])

call dotnet#class('LazyInitializer', 'Object', [ 
  \ dotnet#method('EnsureInitialized(', '!!T& target)', 'static !!T'),
  \ dotnet#method('EnsureInitialized(', '!!T& target, Func valueFLazyInitializery)', 'static !!T'),
  \ dotnet#method('EnsureInitialized(', '!!T& target, bool& initialized, object& syncLock)', 'static !!T'),
  \ dotnet#method('EnsureInitialized(', '!!T& target, bool& initialized, object& syncLock, Func valueFLazyInitializery)', 'static !!T'),
  \ dotnet#method('LazyInitializer(', ')', 'static void .'),
  \ ])

call dotnet#class('ThreadLocal', 'Object', [ 
  \ dotnet#method('ThreadLocal`1(', ')', 'void ThreadLocal`'),
  \ dotnet#method('Finalize(', ')', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#method('ToString(', ')', 'string'),
  \ dotnet#method('get_Value(', ')', '!T'),
  \ dotnet#method('set_Value(', '!T value)', 'void'),
  \ dotnet#method('get_IsValueCreated(', ')', 'bool'),
  \ dotnet#method('get_ValueForDebugDisplay(', ')', '!T'),
  \ dotnet#method('ThreadLocal`1(', ')', 'static void .ThreadLocal`'),
  \ dotnet#prop('Value', '!T'),
  \ dotnet#prop('IsValueCreated', 'bool'),
  \ dotnet#prop('ValueForDebugDisplay', '!T'),
  \ ])

call dotnet#class('SemaphoreSlim', 'Object', [ 
  \ dotnet#method('get_CurrentCount(', ')', 'int32'),
  \ dotnet#method('get_AvailableWaitHandle(', ')', 'WaitHandle'),
  \ dotnet#method('SemaphoreSlim(', 'int32 initialCount)', 'void'),
  \ dotnet#method('SemaphoreSlim(', 'int32 initialCount, int32 maxCount)', 'void'),
  \ dotnet#method('Wait(', ')', 'void'),
  \ dotnet#method('Wait(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('Wait(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('Wait(', 'TimeSpan timeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Release(', ')', 'int32'),
  \ dotnet#method('Release(', 'int32 releaseCount)', 'int32'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#method('SemaphoreSlim(', ')', 'static void .'),
  \ dotnet#prop('CurrentCount', 'int32'),
  \ dotnet#prop('AvailableWaitHandle', 'WaitHandle'),
  \ ])

call dotnet#class('ManualResetEventSlim', 'Object', [ 
  \ dotnet#method('get_WaitHandle(', ')', 'WaitHandle'),
  \ dotnet#method('get_IsSet(', ')', 'bool'),
  \ dotnet#method('set_IsSet(', 'bool value)', 'void'),
  \ dotnet#method('get_SpinCount(', ')', 'int32'),
  \ dotnet#method('set_SpinCount(', 'int32 value)', 'void'),
  \ dotnet#method('ManualResetEventSlim(', ')', 'void'),
  \ dotnet#method('ManualResetEventSlim(', 'bool initialState)', 'void'),
  \ dotnet#method('ManualResetEventSlim(', 'bool initialState, int32 spinCount)', 'void'),
  \ dotnet#method('Set(', ')', 'void'),
  \ dotnet#method('Reset(', ')', 'void'),
  \ dotnet#method('Wait(', ')', 'void'),
  \ dotnet#method('Wait(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('Wait(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('Wait(', 'TimeSpan timeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('Wait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#method('ManualResetEventSlim(', ')', 'static void .'),
  \ dotnet#prop('WaitHandle', 'WaitHandle'),
  \ dotnet#prop('IsSet', 'bool'),
  \ dotnet#prop('SpinCount', 'int32'),
  \ ])

call dotnet#class('CancellationTokenRegistration', 'ValueType', [ 
  \ dotnet#field('m_tokenSource', 'CancellationTokenSource'),
  \ dotnet#field('m_callbackInfo', 'CancellationCallbackInfo'),
  \ dotnet#field('m_registrationInfo', 'SparselyPopulatedArrayAddInfo'),
  \ dotnet#method('CancellationTokenRegistration(', 'class CancellationTokenSource tokenSource, CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo registrationInfo)', 'void'),
  \ dotnet#method('TryDeregister(', ')', 'bool'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('op_Equality(', 'CancellationTokenRegistration left, CancellationTokenRegistration right)', 'static bool'),
  \ dotnet#method('op_Inequality(', 'CancellationTokenRegistration left, CancellationTokenRegistration right)', 'static bool'),
  \ dotnet#method('Equals(', 'object obj)', 'bool'),
  \ dotnet#method('Equals(', 'CancellationTokenRegistration other)', 'bool'),
  \ dotnet#method('GetHashCode(', ')', 'int32'),
  \ ])

call dotnet#class('CancellationTokenSource', 'Object', [ 
  \ dotnet#method('get_IsCancellationRequested(', ')', 'bool'),
  \ dotnet#method('get_IsCancellationCompleted(', ')', 'bool'),
  \ dotnet#method('get_IsDisposed(', ')', 'bool'),
  \ dotnet#method('set_ThreadIDExecutingCallbacks(', 'int32 value)', 'void'),
  \ dotnet#method('get_ThreadIDExecutingCallbacks(', ')', 'int32'),
  \ dotnet#method('get_Token(', ')', 'CancellationToken'),
  \ dotnet#method('get_CanBeCanceled(', ')', 'bool'),
  \ dotnet#method('get_WaitHandle(', ')', '.method'),
  \ dotnet#method('get_ExecutingCallback(', ')', '.method'),
  \ dotnet#method('CancellationTokenSource(', ')', 'void'),
  \ dotnet#method('Cancel(', ')', 'void'),
  \ dotnet#method('Cancel(', 'bool throwOnFirstException)', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('ThrowIfDisposed(', ')', 'void'),
  \ dotnet#method('InternalGetStaticSource(', 'bool set)', 'static CancellationTokenSource'),
  \ dotnet#method('InternalRegister(', 'class Action callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext)', 'CancellationTokenRegistration'),
  \ dotnet#method('CreateLinkedTokenSource(', 'CancellationToken token1, CancellationToken token2)', 'static CancellationTokenSource'),
  \ dotnet#method('CreateLinkedTokenSource(', 'CancellationToken[] tokens)', 'static CancellationTokenSource'),
  \ dotnet#method('WaitForCallbackToComplete(', 'class CancellationCallbackInfo callbackInfo)', 'void'),
  \ dotnet#method('CancellationTokenSource(', ')', 'static void .'),
  \ dotnet#prop('IsCancellationRequested', 'bool'),
  \ dotnet#prop('IsCancellationCompleted', 'bool'),
  \ dotnet#prop('IsDisposed', 'bool'),
  \ dotnet#prop('ThreadIDExecutingCallbacks', 'int32'),
  \ dotnet#prop('Token', 'CancellationToken'),
  \ dotnet#prop('CanBeCanceled', 'bool'),
  \ dotnet#prop('WaitHandle', 'WaitHandle'),
  \ dotnet#prop('ExecutingCallback', 'CancellationCallbackInfo'),
  \ ])

call dotnet#class('CancellationToken', 'ValueType', [ 
  \ dotnet#field('m_source', 'CancellationTokenSource'),
  \ dotnet#method('get_None(', ')', 'static'),
  \ dotnet#method('get_IsCancellationRequested(', ')', 'bool'),
  \ dotnet#method('get_CanBeCanceled(', ')', 'bool'),
  \ dotnet#method('get_WaitHandle(', ')', 'WaitHandle'),
  \ dotnet#method('CancellationToken(', 'class CancellationTokenSource source)', 'void'),
  \ dotnet#method('CancellationToken(', 'bool canceled)', 'void'),
  \ dotnet#method('Register(', 'class Action callback)', 'CancellationTokenRegistration'),
  \ dotnet#method('Register(', 'class Action callback, bool useSynchronizationContext)', 'CancellationTokenRegistration'),
  \ dotnet#method('Register(', 'class Action callback, object state)', 'CancellationTokenRegistration'),
  \ dotnet#method('Register(', 'class Action callback, object state, bool useSynchronizationContext)', 'CancellationTokenRegistration'),
  \ dotnet#method('InternalRegisterWithoutEC(', 'class Action callback, object state)', 'CancellationTokenRegistration'),
  \ dotnet#method('Equals(', 'CancellationToken other)', 'bool'),
  \ dotnet#method('Equals(', 'object other)', 'bool'),
  \ dotnet#method('GetHashCode(', ')', 'int32'),
  \ dotnet#method('op_Equality(', 'CancellationToken left, CancellationToken right)', 'static bool'),
  \ dotnet#method('op_Inequality(', 'CancellationToken left, CancellationToken right)', 'static bool'),
  \ dotnet#method('ThrowIfCancellationRequested(', ')', 'void'),
  \ dotnet#method('ThrowIfSourceDisposed(', ')', 'void'),
  \ dotnet#method('CancellationToken(', ')', 'static void .'),
  \ dotnet#prop('None', 'CancellationToken'),
  \ dotnet#prop('IsCancellationRequested', 'bool'),
  \ dotnet#prop('CanBeCanceled', 'bool'),
  \ dotnet#prop('WaitHandle', 'WaitHandle'),
  \ ])

call dotnet#class('ReaderWriterLockSlim', 'Object', [ 
  \ dotnet#method('ReaderWriterLockSlim(', ')', 'void'),
  \ dotnet#method('ReaderWriterLockSlim(', 'LockRecursionPolicy recursionPolicy)', 'void'),
  \ dotnet#method('EnterReadLock(', ')', 'void'),
  \ dotnet#method('TryEnterReadLock(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('TryEnterReadLock(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('EnterWriteLock(', ')', 'void'),
  \ dotnet#method('TryEnterWriteLock(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('TryEnterWriteLock(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('EnterUpgradeableReadLock(', ')', 'void'),
  \ dotnet#method('TryEnterUpgradeableReadLock(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('TryEnterUpgradeableReadLock(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('ExitReadLock(', ')', 'void'),
  \ dotnet#method('ExitWriteLock(', ')', 'void'),
  \ dotnet#method('ExitUpgradeableReadLock(', ')', 'void'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('get_IsReadLockHeld(', ')', 'bool'),
  \ dotnet#method('get_IsUpgradeableReadLockHeld(', ')', 'bool'),
  \ dotnet#method('get_IsWriteLockHeld(', ')', 'bool'),
  \ dotnet#method('get_RecursionPolicy(', ')', 'LockRecursionPolicy'),
  \ dotnet#method('get_CurrentReadCount(', ')', 'int32'),
  \ dotnet#method('get_RecursiveReadCount(', ')', 'int32'),
  \ dotnet#method('get_RecursiveUpgradeCount(', ')', 'int32'),
  \ dotnet#method('get_RecursiveWriteCount(', ')', 'int32'),
  \ dotnet#method('get_WaitingReadCount(', ')', 'int32'),
  \ dotnet#method('get_WaitingUpgradeCount(', ')', 'int32'),
  \ dotnet#method('get_WaitingWriteCount(', ')', 'int32'),
  \ dotnet#prop('IsReadLockHeld', 'bool'),
  \ dotnet#prop('IsUpgradeableReadLockHeld', 'bool'),
  \ dotnet#prop('IsWriteLockHeld', 'bool'),
  \ dotnet#prop('RecursionPolicy', 'LockRecursionPolicy'),
  \ dotnet#prop('CurrentReadCount', 'int32'),
  \ dotnet#prop('RecursiveReadCount', 'int32'),
  \ dotnet#prop('RecursiveUpgradeCount', 'int32'),
  \ dotnet#prop('RecursiveWriteCount', 'int32'),
  \ dotnet#prop('WaitingReadCount', 'int32'),
  \ dotnet#prop('WaitingUpgradeCount', 'int32'),
  \ dotnet#prop('WaitingWriteCount', 'int32'),
  \ ])

call dotnet#class('Semaphore', 'WaitHandle', [ 
  \ dotnet#method('Semaphore(', 'int32 initialCount, int32 maximumCount)', 'void'),
  \ dotnet#method('Semaphore(', 'int32 initialCount, int32 maximumCount, string name)', 'void'),
  \ dotnet#method('Semaphore(', 'int32 initialCount, int32 maximumCount, string name, [out] bool& createdNew)', 'void'),
  \ dotnet#method('Semaphore(', 'int32 initialCount, int32 maximumCount, string name, [out] bool& createdNew, SemaphoreSecurity semaphoreSecurity)', 'void'),
  \ dotnet#method('OpenExisting(', 'string name)', 'static Semaphore'),
  \ dotnet#method('OpenExisting(', 'string name, SemaphoreRights rights)', 'static Semaphore'),
  \ dotnet#method('Release(', ')', 'int32'),
  \ dotnet#method('Release(', 'int32 releaseCount)', 'int32'),
  \ dotnet#method('GetAccessControl(', ')', 'SemaphoreSecurity'),
  \ dotnet#method('SetAccessControl(', 'class SemaphoreSecurity semaphoreSecurity)', 'void'),
  \ dotnet#method('Semaphore(', ')', 'static void .'),
  \ ])

call dotnet#class('BarrierPostPhaseException', 'Exception', [ 
  \ dotnet#method('BarrierPostPhaseException(', ')', 'void'),
  \ dotnet#method('BarrierPostPhaseException(', 'class Exception innerException)', 'void'),
  \ dotnet#method('BarrierPostPhaseException(', 'string message)', 'void'),
  \ dotnet#method('BarrierPostPhaseException(', 'string message, Exception innerException)', 'void'),
  \ dotnet#method('BarrierPostPhaseException(', 'class SerializationInfo info, StreamingContext context)', 'void'),
  \ ])

call dotnet#class('Barrier', 'Object', [ 
  \ dotnet#method('get_ParticipantsRemaining(', ')', 'int32'),
  \ dotnet#method('get_ParticipantCount(', ')', 'int32'),
  \ dotnet#method('get_CurrentPhaseNumber(', ')', 'int64'),
  \ dotnet#method('Barrier(', 'int32 participantCount)', 'void'),
  \ dotnet#method('Barrier(', 'int32 participantCount, Action postPhaseAction)', 'void'),
  \ dotnet#method('AddParticipant(', ')', 'int64'),
  \ dotnet#method('AddParticipants(', 'int32 participantCount)', 'int64'),
  \ dotnet#method('RemoveParticipant(', ')', 'void'),
  \ dotnet#method('RemoveParticipants(', 'int32 participantCount)', 'void'),
  \ dotnet#method('SignalAndWait(', ')', 'void'),
  \ dotnet#method('SignalAndWait(', 'CancellationToken cancellationToken)', 'void'),
  \ dotnet#method('SignalAndWait(', 'TimeSpan timeout)', 'bool'),
  \ dotnet#method('SignalAndWait(', 'TimeSpan timeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('SignalAndWait(', 'int32 millisecondsTimeout)', 'bool'),
  \ dotnet#method('SignalAndWait(', 'int32 millisecondsTimeout, CancellationToken cancellationToken)', 'bool'),
  \ dotnet#method('Dispose(', ')', 'void'),
  \ dotnet#method('Dispose(', 'bool disposing)', 'void'),
  \ dotnet#prop('ParticipantsRemaining', 'int32'),
  \ dotnet#prop('ParticipantCount', 'int32'),
  \ dotnet#prop('CurrentPhaseNumber', 'int64'),
  \ ])

call dotnet#class('ThreadExceptionEventArgs', 'EventArgs', [ 
  \ dotnet#method('ThreadExceptionEventArgs(', 'class Exception t)', 'void'),
  \ dotnet#method('get_Exception(', ')', 'Exception'),
  \ dotnet#prop('Exception', 'Exception'),
  \ ])

call dotnet#class('ThreadExceptionEventHandler', 'MulticastDelegate', [ 
  \ dotnet#method('ThreadExceptionEventHandler(', 'object object, int method)', 'void'),
  \ dotnet#method('Invoke(', 'object sender, ThreadExceptionEventArgs e)', 'void'),
  \ dotnet#method('BeginInvoke(', 'object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object)', ''),
  \ dotnet#method('EndInvoke(', 'class IAsyncResult result)', 'void'),
  \ ])

